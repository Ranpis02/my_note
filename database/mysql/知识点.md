——b 站 黑马程序员MySQL教程笔记

SQL，英文为 structured Query Language,即结构化查询语言。



[toc]

# 1 MySQL 课程介绍

## 1.1 面试题

1. 什么是事务，以及事务的四大特性？
2. 事务的隔离级别有哪些，MySQL默认是哪几个？
3. 内连接和左外连接的区别是什么？
4. 常用的存储引擎？InnoDB 与 MyISAM 的区别？
5. MySQL 默认InnoDB 的引擎的索引是什么数据结构？
6. 如何查看 MySQL 的执行计划？
7. 索引失效的情况有哪些？
8. 什么是回表查询？
9. 什么是MVCC？
10. MySQL 主从复制的原理是什么？
11. 主从复制之后的读写分离如何实现？
12. 数据库的分库表如何实现？



## 1.2 MySQL的知识点分布



![ ](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/mysql%E5%AD%A6%E4%B9%A0%E7%9F%A5%E8%AF%86%E5%88%86%E5%B8%83.jpg)





# 2 MySQL 概念

## 2.1 数据库相关概念



| **名称**       | **全称**                               | **简称**                         |
| -------------- | -------------------------------------- | -------------------------------- |
| 数据库         | 存储数据的仓库，数据是有组织的进行存储 | DataBase(DB)                     |
| 数据库管理系统 | 操纵和管理数据库的大型软件             | DataBase Management System(DBMS) |
| SQL            | 操作关系型数据库的编程语言             | Structured Query Language(SQL)   |



![](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/SQL%E6%93%8D%E7%BA%B5%E5%85%B3%E7%B3%BB.jpg)



如上图，管理员可以通过 SQL 语言来管理数据库系统，再通过数据系统管理其中的数据库/数据。



## 2.2 MySQL数据库版本

版本

MySQL 官方提供了两种不同的版本:

- 社区版（MySQL  community Server）:  免费，MySQL不提供任何技术支持
- 商业版（MySQL Enterprise Edition）：  收费，可以试用30天，官方提供技术支持





## 2.3 MySQL 的基本配置

### 2.3.1 启动与停止

#### 方式一

按 `win + R` 打开运行windows 的运行窗口，输入 `services.msc`找到 MySQL80 ,右键即可实现==启动/停止==

![image-20220730154021054](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220730154021054.png)



#### 方式二

通过命令行启动与停止 MySQL 服务

启动命令

```shell
net start mysql80
```

停止命令

```shell
net stop mysql80
```



按 win + R 输入 cmd 打开命令行，之后依次启动和停止，如下图： 

![image-20220730155210613](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220730155210613.png)



发现直接拒绝访问，这是由于 启动 和 停止 MySQL服务在主机中是一件很“危险”的事，所以一般用户无法直接通过输入命令执行服务，需要以管理员身份启动，首先在搜索框中输入 cmd ，右键以管理员身份运行 



![image-20220730155458209](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220730155458209.png)



此时我们再运行命令，如下图：

![image-20220730155639375](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220730155639375.png)



**配置文件**

- Windows 中，MySQL 的配置文件为 my.ini

  > 默认存放在  ProgramData > MySQL > MySQL Server 8.0 下

- Linux 中，MySQL 的配置文件为 my.cnf



## 2.3.2 客户端连接

方式一：MySQL 提供的命令行客户端 command  line client

方式二：系统自带的命令行工具执行指令（需要配置环境变量）

```java
mysql -h 主机IP -P 端口 -u 用户名 -p密码
```

> - 小写的 "p" 和密码之间不要有空格
> - 如果 `-p` 后面没有填密码，则回车后会要求输入密码
> - 如果省略 `-h` ，默认主机地址为  `127.0.0.1`；如果省略 `-P`，默认端口号为 3306
> - 在实际开发中，我们需要修改默认端口号，防止被攻击

![mysql三层](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/mysql%E4%B8%89%E5%B1%82.png)

配置环境变量的方法

找到 MySQL 8.0 对应的 bin 文件夹，以默认安装位置为例

将路径 `C:\Program Files\MySQL\MySQL Server 8.0\bin`添加到环境变量中即可生效

在这里，我们使用 MobaXterm 作为工具来连接本地的 MySQL,显示效果如下：

![image-20220730165010710](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220730165010710.png)

## 2.4 图形化界面 Datagrip 的使用

能够操作 MySQL 的图形化界面工具很多，市面上最常见的是如下三种：

![image-20220818150021761](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220818150021761.png)

本次课程我们所使用的的是 DataGrip ，其功能相对于前面两种而言更加丰富。

### 2.4.1 配置 DataGrip

第一步，创建一个 project ，File → New → Project 

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220818150514788.png" alt="image-20220818150514788" style="zoom:50%;" />

第二步，添加数据源，之后配置其连接信息（如果是第一次，那么要需要下载相关的驱动）

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220818161525738.png" alt="image-20220818161525738" style="zoom: 25%;" />

在其左下角还有一个<font color="red">Test Connection</font> 用来测试连接是否成功

第三步，创建数据库，右键 @localhost，找到 New → Schema，这个Schema(架构)就相当于我们的数据库

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220818162033920.png" alt="image-20220818162033920" style="zoom: 50%;" />

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220818162400239.png" alt="image-20220818162400239" style="zoom: 25%;" />

第四步，由于新建的数据库是不存在表结构的，所以我们此时需要添加表

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220818162535933.png" alt="image-20220818162535933" style="zoom: 50%;" />

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220818162959712.png" alt="image-20220818162959712" style="zoom:50%;" />

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220818163106059.png" alt="image-20220818163106059" style="zoom:50%;" />



## 2.5 数据模型

关系型数据库(RDBMS)

概念：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库。

特点：

1. 使用表存储数据，格式统一，便于维护
2. 使用 SQL 语言操作，标准统一，使用方便

> 由此我们可以知道，关系型数据库的一个判断依据是是否由表结构来存储数据。



# 3 SQL 基础语法

## 3.1 SQL 通用语法

1. SQL 语句可以单行或多行书写，以==分号==结尾

2. SQL 语句可以使用空格 / 缩进 来增强语句的可读性

3. MySQL 数据库的SQL 语句不区分大小写，关键字建议使用大写

4. 注释：

   >- 单行注释：-- 注释内容（"--"后面接空格）或者 #注释内容(MySQL所特有)
   >- 多行注释：/\* 注释内容 \*/



## 3.2 SQL 分类

| **分类** | **全称**                   | **说明**                                               |
| -------- | -------------------------- | ------------------------------------------------------ |
| DDL      | Data  Definition Language  | 数据定义语言，用于定义数据库对象（数据、表、字段）     |
| DML      | Data Manipulation Language | 数据操作语言，用来对数据库表中的数据进行增删改         |
| DQL      | Data Query Language        | 数据查询语言，用来查询数据库中表的记录                 |
| DCL      | Data Control Language      | 数据控制语言，用来创建数据库用户、控制数据库的访问权限 |



### 3.2.1 DDL -数据库操作

#### 查询

查询所有数据库

```mysql
show databases;
```



查询当前数据库

```mysql
select database();
```



#### 创建

```mysql
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
    [create_option] ...

create_option: [DEFAULT] {
    CHARACTER SET [=] charset_name
  | COLLATE [=] collation_name
  | ENCRYPTION [=] {'Y' | 'N'}
}
```

- CHARACTER SET：指定数据库采用的字符集，如果不指定字符集，默认 utf8mb4
- COLLATE：指定数据库字符集的校对规则，常用的有：
  - utf8_bin：区分大小写
  - utf8_general_ci：不区分大小写
  - utf8mb4_0900_ai_ci：不区分大小写，MySQL8 默认校对规则

 **示例**

```mysql
# 创建 my_db
CREATE DATABASE my_db;
# 删除数据库
DROP DATABASE my_db;

# 创建 reading 数据库，并指定字符编码为 utf8mb4
CREATE DATABASE reading CHARACTER SET utf8mb4;
DROP DATABASE reading;

# 创建 reading 数据库，并指定字符编码为i utf8，校对规则为utf8_bin
CREATE DATABASE reading CHARACTER SET utf8 COLLATE utf8_bin;
DROP DATABASE reading;

# 如果创建的数据库名称中含有mysql关键字，需要使用反引号将其括起来
create database `create`;
```

> MySQL 在 5.5.3 之后增加了 utf8mb4 的编码，mb4 就是 most bytes 4 的意思，专门用来兼容四个字节的 unicode 。也就说 utf8mb4 是 utf8 的超集。



#### 删除

```mysql
drop database [if exists] 数据库名;
```



#### 使用

```mysql
use 数据库名;
```



#### 清屏

```mysql
system cls;
```



### 3.2.2 DDL-表操作

#### 查询当前数据库所有表

```mysql
show tables;
```



#### 查询表结构

```mysql
desc <表名>;
```

或者

```mysql
describle <表名>
```



#### 查询建表语句

```mysql
show create table <表名>;
```

> 相较 `describle <表名>`语句，该语句能查看的信息内容更加丰富，如下：
>
> `decrible <表名>`语句查询的结果如下:
>
> ![image-20220731230141133](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220731230141133.png)
>
> 而 `show create table <表名>`语句的查询结果如下:
>
> ![image-20220731230304020](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220731230304020.png)
>
> 我们除了字段和字段类型，还可以看到其编码方式和存储引擎以及注释内容
>
> 在《C语言中文网》中，我们了解到加了 `\g` 或者是 `\G`后会使得显示变得规范，但 `\g` 或 `\G` 其实也是一个结束符，无法和 `;`一起使用，特别在 datagrip 中，`\g` 和 `\G`属于错误语法。
>
> 

#### *创建

```mysql
create table table_name(
	列名 类型 [comment '注释'],
	列名 类型 [comment '注释'],
	……
	列名 类型 [comment '注释']
)character set 字符集 collate 校对规则 engine 引擎 comment '表注释';
```

> […]为可选参数，创建表的最后一个字段没有逗号，结束语句后需要加上分号

- character set：指定字符集，如果未指定则为所在数据库的字符集
- collate：指定校对规则，如果未指定则为所在数据库的字符集
- engine：这部分涉及较多，默认为 Innodb



#### 删除表

```mysql
DROP TABLE 表名
# 或
truncate table 表名
```



#### *修改表结构

在 MySQL 中可以使用 `ALTER TABLE` 来修改原有的表结构，例如一下操作：

- 增加列
- 删除列
- 修改字段类型
- 重定义列
- 重命名表

具体的语法格式

```mysql
alter table <表名>[修改选项]
```

修改选项的语法格式如下：

```mysql
add column <列名><类型>	-- 增加列
drop column <列名> 	-- 删除列
modify column <列名><新类型>		-- 修改字段类型
change column <旧列名> <新列名> <新列类型>	-- 重定义列
rename to <新表名>	-- 重命名表
```

**修改表名**

```mysql
Rename table 表名 to 新表名
```

**修改字符集**

```mysql
alter table 表名 character set 字符集
```

**示例**

```mysql
# 事先准备好一张表
CREATE TABLE emp(
	id INT,
	`name` varchar(32),
	sex char(1),
	birthday DATE,
	entry_date DATETIME,
	job varchar(32),
	salary DOUBLE,
	resume TEXT
);

-- 在员工表上增加一个image字段，varchar类型，要求在resume后面,默认为空串
ALTER TABLE emp
	ADD image VARCHAR(32) NOT NULL DEFAULT ''
	AFTER resume;

-- 修改job列，使其长度变为60
ALTER TABLE emp
	MODIFY job VARCHAR(60);
	
-- 删除sex列
ALTER TABLE emp
	DROP sex;
	
-- 修改表名为employee
RENAME TABLE emp TO employee;

-- 修改表的字符集为utf8
ALTER TABLE employee CHARACTER SET utf8;

-- 修改name为emp_name
ALTER TABLE employee
	CHANGE `name` `emp_name` VARCHAR(32);

DESC employee;
```



### 3.2.3 DML 

#### 3.2.3.1 DML 介绍

在前面，我们知道 DDL 语句是用来<font color="red">操作数据库、数据库表和表中字段</font>

而 DML ，英文全称是 Data Manipulation Language (数据操作语言)，<font color="red">用来对数据库中表的数据记录进行增删改操作</font>

- 添加数据：INSERT
- 修改数据：UPDATE
- 删除数据：DELETE



#### 3.2.3.2 添加数据

1. 给指定字段数据数据

   ```mysql
   INSERT INTO 表名(字段名1,字段名2,…) VALUES(值1,值2,…);
   ```

2. 给全部字段添加数据（即使有字段有默认值，也不能缺省）

   ```mysql
   INSERT INTO 表名 VALUES(值1,值2,…);
   ```

3. 批量添加数据

   ```MYSQL
   INSERT INTO 表名(字段名1,字段名2,…) VALUES(值1,值2,…),(值1,值2,…)…;
   ```

   ```mysql
   INSERT INTO 表名 VALUES(值1,值2,…),(值1,值2,…),…;
   ```

注意：

- 插入数据时，指定的字段顺序需要与值的顺序是一一对应的
- 字符串和日期类型数据应该包含在引号中
- 插入的数据大小，应该在字段的指定范围内

#### 3.2.3.3 修改数据

```mysql
UPDATE 表名 SET 字段名1 = 值1,字段名2 = 值2，… [WHERE 条件]
```

<font color="red">注意：修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据</font>

#### 3.2.3.4 删除数据

```mysql
DELETE FROM 表名 [WHERE 条件]
```

注意：

- DELETE 语句的条件可以有，也可以没有，如果没有条件，则默认删除整张表的所有数据
- <font color="red">DELETE 语句不能删除某一列的数据</font>
- 使用 delete 语句仅删除记录，不删除表本身，如要删除表，使用 `drop table 表名` 语句





#### 3.2.3.5  综合练习

```mysql
# 创建 employee 表
CREATE TABLE employee(
    id int comment '员工编号' ,
    work_no varchar(10) comment '工作编号',
    name varchar(10) comment '姓名',
    gender char(1) comment '性别',
    age tinyint unsigned comment '年龄',
    id_card char(18) comment '信用卡号',
    entry_date date comment '入职时间'
);
# 一般而言，我们都需要给表结构添加主码，外码或约束之类的条件
################################################################################
# 插入记录
INSERT INTO employee VALUES(1,'1000011001','小明','男',18,'7769669','2022-8-18');
INSERT INTO employee VALUES(2,'1000011002','小红','女',19,'7769670','2022-8-18');
INSERT INTO employee VALUES(3,'1000011003','小章','男',18,'7769671','2022-8-18');
INSERT INTO employee VALUES(4,'1000011004','小花','女',19,'7769672','2022-8-18');
INSERT INTO employee VALUES(5,'1000011005','小梅','女',18,'7769673','2022-8-18');
#################################################################################
# 更新数据
# 更新1：将小红的年龄改成 20
UPDATE employee SET age=20 WHERE name='小红';
# 更新2：将所有人的入职时间改成'2022-8-19'
UPDATE employee SET entry_date='2022-8-19';
#################################################################################
# 删除数据
# 小梅被我辞退了，请从员工表中将她删除
DELETE from employee WHERE name='小梅';
# 公司倒闭，员工跑路
DELETE FROM employee;
```



### 3.2.4 DQL （查询语句）

在实际生活中，<font color="red">查询语句用的次数要远高于增删改的次数</font>。例如，我们去逛淘宝，那么一般用户做的都是查询，而非增删改。

综合语法如下：

```mysql
SELECT 字段列表
FROM 表名列表
WHERE 条件列表
GROUP BY 分组字段列表
HAVING 分组后条件列表
ORD BY 排序字段列表
LIMIT 分页参数
```

#### 3.2.4.1 基础查询

- 查询多个字段

```mysql
SELECT 字段1,字段2,字段3,… FROM 表名;
```

```mysql
SELECT * FROM 表名;
```

> `*`代表表中所有字段名

- 设置别名

```mysql
SELECT 字段1 [AS 别名],字段2 [AS 别名] … FROM 表名; 
```

设置别名的作用是为了方便在控制台查看结果，例如：

```mysql
SELECT workaddress AS '工作地址' FROM emp;
```

此时在控制台显示的列名就是 工作地址

- 去除重复记录（添加关键字 `distinct`）

```mysql
SELECT DISTINCT 字段列表 FROM 表名;
```

#### 3.2.4.2 条件查询

```mysql
SELECT 字段列表 FROM 表名 WHERE 条件列表;
```

条件：

| 比较运算符      | 功能                                         |
| --------------- | -------------------------------------------- |
| >               | 大于                                         |
| >=              | 大于等于                                     |
| <               | 小于                                         |
| <=              | 小于等于                                     |
| =               | 等于                                         |
| <> 或 !=        | 不等于                                       |
| BETWEEN … AND … | 在某个范围之内（含最大、最小值）             |
| IN(…)           | 在 IN 之后的列表中的值，多选一               |
| LIKE 占位符     | 模糊匹配（`_`匹配单个字符，`%`匹配多个字符） |
| IS NULL         | 判断是否为空                                 |
| IS NOT NULL     | 判断是否为非空                               |

逻辑运算符：

| 逻辑运算符 |   功能   |
| :--------: | :------: |
| && 或 AND  |  且运算  |
| OR 或 \|\| |  或运算  |
|  NOT 或 !  | 取反运算 |

#### 3.2.4.3 聚合函数

聚合函数：将一列数据作为一个整体，进行纵向计算

常见的聚合函数：

| 函数  |   功能   |
| :---: | :------: |
| count | 统计数量 |
|  max  |  最大值  |
|  min  |  最小值  |
|  avg  |  平均值  |
|  sum  |   求和   |

<font color="red">注意：我们在使用聚合函数时，所有的 NULL 值不参与运算 </font>

:four_leaf_clover:**count(*)    和    count(列)   的区别**

- cout(*)：统计满足条件的记录的行数
- count(列):    统计列中属性值满足条件的有多少行，但是会排除属性值为  null 的情况



#### 3.2.4.4 分组查询

语法：

```mysql
SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];
```

:bell: WHREE 与 HAVING 之间的区别：

- 执行时机不同：WHERE 是分组之前进行过滤，不满足 WHERE 条件，不参与分组；而 HAVING 是分组之后的结果进行过滤
- 判断条件不同：WHERE 不能对聚合函数进行判断，而 HAVING 可以

:heavy_exclamation_mark:注意事项：

- 执行顺序：where  >  聚合函数  >  having
- 分组之后，<font color="red">查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</font>

示例：（以之前创建的 employee 表为例）

```mysql
-- 1.根据性别分组，统计男员工和女员工的数量
select gender AS '性别',count(*) AS '数量' from employee group by gender;
-- 2.根据性别进行分组，统计男员工和女员工的平均年龄
select gender AS '性别',avg(age) AS '平均年龄' from employee group by gender;
-- 3.根据年龄分类，查询相同年龄数大于等于3的年龄
select age,count(*) age_count from employee group by age having age_count >= 3;
```

#### 3.2.4.5 排序查询

```mysql
SELECT 字段列表 FROM  表名 ORDER BY 字段1 排序方式,字段2 排序方式2…;
```

排序方式：

- ASC：升序（默认值）
- DESC：降序

<font color="red">注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</font>

#### 3.2.4.6 分页查询

```mysql
SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询记录数
```

:heavy_exclamation_mark:注意：

- 起始索引从 0 开始，起始索引 = （查询页码 - 1） * 每页显示记录数
- 分页查询是数据库的方言^*^，不同的数据库有不同的实现， MySQL 中是 ==LIMIT==
- 如果查询的是第一页数据，起始索引可以省略

举例：（以之前创建的 employee 表为例）

```mysql
# 插入10条记录
INSERT INTO employee VALUES(1,'1000011001','小明','男',18,'7769669','2022-8-18');
INSERT INTO employee VALUES(2,'1000011002','小红','女',19,'7769670','2022-8-18');
INSERT INTO employee VALUES(3,'1000011003','小章','男',18,'7769671','2022-8-18');
INSERT INTO employee VALUES(4,'1000011004','小花','女',19,'7769672','2022-8-18');
INSERT INTO employee VALUES(5,'1000011005','小梅','女',18,'7769673','2022-8-18');
INSERT INTO employee VALUES(6,'1000011006','小芳','男',18,'7769674','2022-8-18');
INSERT INTO employee VALUES(7,'1000011007','小强','女',19,'7769675','2022-8-18');
INSERT INTO employee VALUES(8,'1000011008','小绿','男',18,'7769676','2022-8-18');
INSERT INTO employee VALUES(9,'1000011009','小王','女',19,'7769677','2022-8-18');
INSERT INTO employee VALUES(10,'1000011010','小三','女',18,'7769678','2022-8-18');
```

假设现在每一页有5记录，一共有2页，现在我想要从第1页开始阅读，那么查询语句为：

```mysql
select * from employee limit 0,5;
```

或者

```mysql
select * from employee limit 5;
```

假如我想要从第2页开始看，那么查询语句为：

```mysql
select * from employee limit 5,5;
```



#### 3.2.4.7 案例：按照需要完成如下 DQL 语句编写

假设我们的字段现在有一张 employee 表，表中字段有：id、work_no、name、gender、age、id_card、work_address、entry_date共八个字段，问：

1. 查询年龄为20,21,22,23岁的女性员工信息。
2. 查询性别为男，并且年龄在20-40岁（含）以内的姓名为三个字的员工。
3. 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。
4. 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。
5. 查询性别为男，且年龄在20-40岁（含）以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序。

```mysql
-- 1. 查询年龄为20,21,22,23岁的员工信息。
select * from employee where gender = '女' and age in (20, 21, 22, 23);

-- 2. 查询性别为男，并且年龄在20-40岁（含）以内的姓名为三个字的员工。
select * from employee where gender = '男' and  age between 20 and 40 and name like '___'; -- 一个下划线代表一个字符，三个下划线代表三个字符

-- 3. 统计员工表中，年龄小于60岁的，男性员工和女性员工的人数。
select gender, count(*) AS age_count from employee where age < 60 group by gender;

-- 4. 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。
select name, age from employee where age <= 35 order by age asc,entry_date desc;

-- 5. 查询性别为男，且年龄在20-40岁（含）以内的前5个员工信息，对查询的结果按年龄升序排序，年龄相同按入职时间升序排序。
select * from employee where gender = '男' and age between 20 and 40 order by age ,entry_date desc limit 5;
```



#### 3.2.4.8 DQL 执行顺序

DQL语句的执行顺序如下：

```mermaid
flowchart LR
A(1 from和join) --> B(2 where)
B --> C(3 group by)
C --> D(4 having) 
D --> E(5 select)
E --> F(6 order by)
F --> G(7 limit)
```



### 3.2.5 DCL(控制语句)

DCL 全称是 Data Control Language（数据控制语言），用来管理数据库用户、控制数据库的访问权限

#### 3.2.5.1 用户管理

- 查询用户

  ```mysql
  USE mysql;
  SELECT * FROM user;
  ```

- 创建用户

  ```mysql
  CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
  ```

- 修改用户密码

  ```mysql
  ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码';
  ```

- 删除用户

  ```mysql
  DROP USER '用户名'@'主机名';
  ```

注意：

- 主机名可以使用`%`通配
- 这类 SQL 开发人员操作的比较少，主要是 DBA （Data Administrator，数据库管理员）使用

练习：

```mysql
-- 1.创建用户 'itcast',只能在本地主机 localhost 访问，密码为123456
create user 'itcast'@'localhost' identified by '123456';

-- 2.创建用户 heima，可以在任意主机访问该数据库，密码为123456
create user 'heima'@'%' identified by '123456';

-- 3.修改用户 heima 的访问密码为 1234
alter user 'heima'@'%' identified with mysql_native_password by '1234';

-- 4.删除 itcast@localhost 用户
drop user 'itcast'@'localhost';
```

当我们完成第二步操作后，打开终端，验证是否能够登录：

![image-20220819112516667](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819112516667.png)

登录成功后我们使用`show databases;`发现只有一个数据库，其他的数据库由于无权限无法查询

![image-20220819114902930](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819114902930.png)



#### 3.2.5.2 权限控制

MySQL 中定义了多种权限，但是常用的就以下几种：

| 权限                | 说明               |
| ------------------- | ------------------ |
| ALL, ALL PRIVILEGES | 所有权限           |
| SELECT              | 查询数据           |
| INSERT              | 插入数据           |
| DELETE              | 删除数据           |
| ALTER               | 修改表             |
| DROP                | 删除数据库/表/视图 |
| CREATE              | 创建数据库/表      |

- 查询权限

  ```mysql
  SHOW GRANTS FOR '用户名'@'主机名'
  ```

- 授予权限

  ```mysql
  GRANT 权限列表 ON 数据名.表名 TO '用户名'@'主机名';
  ```

- 撤销权限

  ```mysql
  REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'
  ```

注意：

- 多个权限之间，使用逗号分隔
- 授权时，数据库名和表名可以使用`*`进行通配，代表所有

练习：

```mysql
-- 1.查询 "黑马" 的权限
show grants for 'heima'@'%';

-- 2.授予权限
grant all on itcast.* to 'heima'@'%';   # 这条命令将数据库 itcast 的权限都授予 heima

-- 3.撤销权限
revoke all on itcast.* from 'heima'@'%';
```

第一条命令的执行结果为：

![image-20220819122122708](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819122122708.png)

这代表着没有赋予"heima"这个用户任何权限，用户"heima"只能连接数据库和登录



### 3.2.6 重要：备份和恢复数据库

- 备份数据库命令（注意：需要在 DOS 下执行）

  ```bash
  mysqldump -u 用户名 -p -B db_name1 db_name2 > 文件名.sql
  ```

  > 如果我们想要备份指定的表，则需要使用可以使用如下命令：
  >
  > ```
  > mysqldump -u 用户名 -p密码 数据库 表1 表2 表n > 文件名.sql
  > ```

- 恢复数据库命令（需要进入到 MySQL 命令行中执行）

  ```mysql
  source 文件名.sql
  ```



**示例**

```bash
# 在 DOS 中备份数据库 test 和 test_db
mysqldump -u root -p -B test_db test > d:\\bak.sql

# 在 MySQL 命令行中恢复数据库
source d:\\bak.sql
```



## 3.3 数据类型

![image-20230307165436373](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230307165436373.png)

对 bit(m) 类型的说明：

- <strong style="color:red">bit 字段显示时，按照位的方式显示</strong>
- 如果只有 0 和 1，可以考虑使用 `bit(1)` 节省空间
- 平时使用不多

对 decimal(M, D) 类型的说明：

- 可以支持更加精确的小数位数，M 是精度，而 D 是标度
- M 最大是65；D 最大是30。如果 M 被省略，默认是 10,；如果 D 被省略，默认是 0

对 `char(size)` 和 `varchar(size)` 说明：

- char(size) 表示固定长度字符串，范围为 0~255，最大可存储 <strong style="color:red">255 字符</strong>

- varchar(size) 表示可变长度在字符串，范围为 0~65535，最大可存储 <strong style="color:red">65532 字节</strong>

  > 去掉 3 个字节用来保存字符串长度

需要注意的是：字符 ≠ 字节，在不同的编码格式有自己的转换，例如在 utf8 下，1 字符 = 3 字节，我们可以思考一下，因为 varchar 会要空出 3 个字节用来存储数据长度，所以如果是在 utf8 下，最大可以可存储的字符数 = $65532 \div 3 = 21844$



**char 和 varchar 的应用场景**

1. 如果数据是定长的，推荐使用 char，例如 <u>md5 的密码、邮编、手机号、身份证号</u>等
2. 如果一个字符的长度是不确定的，推荐使用 varchar，例如：<u>留言、文章</u>等
3. 就查询速度而言，char > varchar

> 对于文本而言，我们也可以使用 Text 数据类型，将 Text 列视为 varchar 列，注意 Text 不能有默认值，大小为 0-2^16^ 字节 





### 3.3.1 数据类型分类

MySQL（或者说 sql 语言） 中数据类型有很多，主要分为：

- 数值类型
- 字符串类型
- 日期时间类型

### 3.3.2 数值类型

|             **类型**             |            **大小**             |
| :------------------------------: | :-----------------------------: |
|             TINYINT              |             1 byte              |
|             SMALLINT             |             2 bytes             |
|            MEDIUMINT             |             3 bytes             |
|          INT 或 INTEGER          |             4 bytes             |
|              BIGINT              |             8 bytes             |
|  <font color="red">FLOAT</font>  |             4 bytes             |
| <font color="red">DOUBLE</font>  |             8 bytes             |
| <font color="red">DECIMAL</font> | 依赖于M（精度）和 D（标度）的值 |

> 对于精度和标度的区分：精度指的是数字的位数，而标度指的是小数点后的位数。
>
> 像 double 类型，我们则需要指定其精度和标度，例如：`score double(4,1)`，double 里面指定的两个参数前面一个代表精度，而后面一个则代表标度。



---

<font color="red">我们在设计数据库时，尽量使字段对应的数据类型是能包容存储字节数的最小数据类型。</font>

例如：一般人的年龄都是在0 ~ 100，最高也不会超过200，所以我们可以使用 TINYINT 来指定字段类型，但是 TINYINT 真的就可以吗？ TINYINT 只占用一个字节，范围在[-128,127]，可是显然有些人的岁数却能达到128甚至更大，所以我们可以考虑 使用无符号的 TINYINT ，只需要在 TINYINT 后面加上 UNSIGNED 

---



### 3.3.3 字符串类型

| **类型**   | **大小**         | **描述**                     |
| ---------- | ---------------- | ---------------------------- |
| CHAR       | 0-255 bytes      | 定长字符串                   |
| VARCHAR    | 0-65535 bytes    | 变长字符串                   |
| TINYBLOB   | 0-255 bytes      | 不超过255个字符的二进制数据  |
| TINYTEXT   | 0-255 bytes      | 短文本字符串                 |
| BLOB       | 0-65535 bytes    | 二进制形式的长文本数据       |
| TEXT       | 0-65535 bytes    | 长文本数据                   |
| MEDIUMBLOB | 0-16777215 bytes | 二进制形式的中等长度文本数据 |



> 我们目前只需要了解 `char` 和 `varchar` 数据类型，`char` 类型相较于 `varchar`而言效率更高，像是如果我们假定有一个字段为用户名，用户名长度为0-50个字符，那么此时我们选择 `varchar` 来作为存储类型，因为这样可以节省存储空间，而对于性别，由于字符串长度不是男就是女，所以我们选择 `char` 类型来作为存储类型



### 3.3.4 日期类型

| 类型      | 大小 | 范围                                        | 格式                |
| --------- | ---- | ------------------------------------------- | ------------------- |
| DATE      | 3    | 1000-01-01 至 9999-12-31                    | YYYY-MM-DD          |
| TIME      | 3    | -838:59:59至838:59:59                       | HH:MM:SS            |
| YEAR      | 1    | 1901 至 2155                                | YYYY                |
| DATETIME  | 8    | 1000-01-01 00:00:00  至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS |
| TIMESTAMP | 4    | 1970-01-01 00:00:00 至 2038-01-19 03:14:07  | YYYY-MM-DD HH:MM:SS |

**示例**

```mysql
CREATE TABLE t1(
	birthday DATE,			-- 年-月-日
	job_time DATETIME,	-- 年-月-日 时:分:秒
	login_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP	-- 时间戳，设置后如果没有指定默认为当前时间的时间戳，并且在每次更新字段后都会重新设置
);

INSERT INTO t1(birthday, job_time) values('2023-03-07', '2023-03-07 18:19:00');

SELECT * from t1;
```



### 3.3.5 案例

设计一张员工信息表，要求如下：

1. 编号（纯数字）
2. 员工工号（字符串类型，长度不超过10位）
3. 员工姓名（字符串类型，长度不超过10位）

4. 性别（男  / 女，存储一个汉字）
5. 年龄（正常人年龄，不可能存储负数）
6. 身份证号（二代身份证号均为18位，特别注意有的身份证号有 x 这样的字符 ）
7. 入职时间（取值年月日即可）


```mysql
create table emp(
    id INT comment '编号',
    work_id  VARCHAR(10) comment '员工工号',
    name VARCHAR(10) comment '员工姓名',
    gender CHAR(1) comment '性别',
    age TINYINT UNSIGNED comment '年龄',
    id_card VARCHAR(18) comment '身份证号',
    entry_date DATE comment '入职时间'
) comment '员工信息表';
```



# 4 函数

<font color="red">函数：被封装好的一段可以直接被另一程序调用的程序或代码</font>



## 4.1 字符串函数

MySQL 中 内置了很多的字符串函数，常用的几个如下：

| 函数                     | 功能                                                        |
| ------------------------ | ----------------------------------------------------------- |
| CONCAT(S~1~,S~2~,…,S~n~) | 字符串                                                      |
| LOWER(str)               | 将字符串str全部转化为小写                                   |
| UPPER(str)               | 将字符串str全部转化为大写                                   |
| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度   |
| RPAD(str,n,pad)          | 有填充，用字符串pad对str的右边进行填充，达到n个字符串的长度 |
| TRIM(str)                | 去掉字符串头部和尾部的空格                                  |
| SUBSTRING(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串             |
| LENGTH(str)              | 返回 str 长度                                               |
| CONCAT(str1, str2, …)    | 连接字符串                                                  |

> - `LOWER()` 等同于 `LCASE()`，`UPPER()` 等同于 `UCASE()`
>
> - `TRIM` 又可以分为 `LTRIM` 和 `RTRIM`



**练习：首先我们 Ctrl + Shfit + Q 新建一个控制台**

```mysql
-- concat
select concat('Hello','MySQL');

-- lower
select lower('HELLO');

-- upper
select upper('hello');

-- lpad
select lpad('01',5,'-');

-- rpad
select rpad('01',5,'-');

-- trim
select trim(' hello mysql ');

-- subsrting
select substring('hello mysql',1,5);    # 截取的值为 hello
```



**案例：根据业务需求完成以下 SQL 编写**

```
题目：由于业务需求变更，企业员工的工号，统一为15位数，目前不足5位数的全部在前面补上0.比如：1号员工的工号应该为00001。
```

```mysql
-- 由于我们之前已经设置了 employee 的 work_no 最大为10位，所以这时候需要先修改表的结构
use test_db
alter table employee
modify column work_no varchar(15);

-- 再来完成左填充
update employee set work_no = lpad(work_no,15,'0');
```

显示结果：

![image-20220819154533259](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819154533259.png)



## 4.2 数值函数

常见的数值函数如下：

| 函数                           | 功能                               |
| ------------------------------ | ---------------------------------- |
| ABS(x)                         | 绝对值                             |
| CEIL(x)                        | 向上取整                           |
| FLOOR(x)                       | 向下取整                           |
| MOD(x,y)                       | 返回 x mod y                       |
| RAND()                         | 返回0~1的随机数                    |
| ROUND(x,y)                     | 求参数x的四舍五入的值，保留y位小数 |
| FORMAT(number, decimal_places) | 保留小数位数                       |

**案例：通过数据库的函数，生成一个六位数的随机验证码**

```mysql
-- 我们可以先通过 rand()函数生成一个介于0-1的小数，将其放大1,000,000倍，之后取整即可
select round(rand()*1000000,0);

-- 但如果一旦出现 rand() 函数生成一个 0.019216 这类的小数，那么将只有5位小数，所以这时我们需要使用 lpad 函数进行填充
-- 正确写法如下：
select lpad(round(rand()*1000000,0),6,'0')
```

效果图：

![image-20220819172624064](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819172624064.png)



## 4.3 日期函数

| 函数                               | 功能                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| CURDATE()                          | 返回当前日期（年月日）                                       |
| CURTIME()                          | 返回当前时间（时分秒）                                       |
| CURRENT_TIMESTAMP()                | 返回当前时间戳                                               |
| NOW()                              | 返回当前日期和时间                                           |
| YEAR(date)                         | 获取指定 date 的年份                                         |
| MONTH(date)                        | 获取指定 date 的月份                                         |
| DAY(date)                          | 获取指定 date 的日期                                         |
| DATE_ADD(date,INTERVAL_expr type ) | 返回一个日期/时间值加上一个时间间隔 expr 后的时间值          |
| DATE_SUB(date,INTERVAL_expr type ) | 返回一个日期/时间值减去一个时间间隔 expr 后的时间值          |
| DATEDIFF(date1,date2)              | 返回起始时 date1 和结束时间 date2 之间的==天数==(date1-date2) |
| DATE(datetime)                     | 返回datetime的日期部分                                       |

练习：

```mysql
-- curdate
select curdate();

-- curtime
select curtime();

-- now
select now();

-- year,month,day
select year(now());
select month(now());
select day(now());

-- date add
select date_add(now(),INTERVAL 1 year);
select date_add(now(),INTERVAL 1 month);
select date_add(now(),INTERVAL 1 day);

-- datediff
select datediff('2022-08-19','2021-08-19');
```

**案例：查询所有员工的入职天数，并按照入职天数倒序排序**

```mysql
select name,datediff(curdate(),entry_date) as 'entry_days' from employee order by entry_days desc;
```



## 4.4 流程控制函数

流程控制函数也是很常用的一类函数，可以在 SQL 语句中实现条件筛选，从而提高查询语句的效率

| 函数                                                   | 功能                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| IF(value,t,f)                                          | 如果value为 true，则返回 t, 否则返回 f                       |
| IFNULL(value1,value2)                                  | 如果value1不为空，则当返回value1，否则返回value2             |
| CASE WHEN [val1] THEN [res1]…ELSE [default] END        | 如果 val1 为 true ，返回 res1,…否则返回 default 默认值       |
| CASE [expr] WHEN [val1] THEN [res1]…ELSE [default] END | 如果 expr的值等于 val1 ，返回 res1 ,…，否则返回 default 默认值 |

**练习：**

```mysql
-- 流程控制函数
-- if
select if(false,'ok','Error');

-- ifnull
select ifnull('OK','Default'); # 返回 OK
select ifnull('','Default');    # 返回''
select ifnull(null,'Default');  # 返回 Default

-- case函数
-- 需求：监察部门到了，需要判断哪些员工属于未成年
select
    name,
    (case when age<18 then '未成年' else '成年' end) as 'judge_adult'
from employee;
```

案例：统计班级各个学院的成绩，展示规则如下：

- score >= 85 ,展示优秀；
- score >= 60,展示及格
- 否则，展示不及格

准备工作：首先，准备一张学生分数表：

```mysql
-- 进入准备的数据库
use test_db;
-- 建表
create table score(
    id int comment 'ID',
    name varchar(20) comment '姓名',
    math int comment '数学',
    English int comment '英语',
    Chinese int comment '语文'
) comment '学院成绩表';
-- 插入数据
insert into score(id,name,math,English,Chinese) values(1,'Tom',67,88,95);
insert into score(id,name,math,English,Chinese) values(2,'Rose',23,66,90);
insert into score(id,name,math,English,Chinese) values(3,'Jack',56,98,76);
```

实现代码：

```mysql
select
    id,
    name,
    (case when math >= 85 then '优秀' when math >= 60 then '及格' else '不及格' end) '数学',
    (case when English >= 85 then '优秀' when English >= 60 then '及格' else '不及格' end) '英语',
    (case when Chinese >= 85 then '优秀' when Chinese >= 60 then '及格' else '不及格' end) '语文'
from score;
```

执行结果为：

![image-20220819192546562](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819192546562.png)



## 4.6 加密和系统函数

| 函数              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| USER()            | 查询用户                                                     |
| DATABASE()        | 数据库名称                                                   |
| MD5()             | 通过MD5算法加密字符串                                        |
| ~~PASSWORD(str)~~ | ~~从原文密码str计算并返回密码字符串，通常用于对mysql数据库的用户密码加密~~ |

> `MD5()` 是一种单向不可逆的加密函数，计算得出的数据为 128 位，在 16 进制下长度为 32，目前 MD5 加密算法已经被破解，并不是一种安全的加密算法

**示例**

```mysql
# 查看登录当当前mysql的用户@IP地址
SELECT USER() FROM DUAL;

# MD5加密
SELECT MD5('admin');

# 查询mysql数据库中user表中内容数据
SELECT * from mysql.user;

# 在mysql.user中，用户密码即是通过password函数计算得来的
-- SELECT PASSWORD('admin');
```

> 说明：MySQL 8.0 已经废弃 password 字段和 PASSWORD() 函数，加密方式由原来的 mysql_native_password 修改为 caching_sha2_password



# 5 约束

## 5.1 概述

1. 概念：<font color="red">约束是作用于表中字段上的规则，用于限制存储在表中的数据。</font>

2. 目的：<font color="red">保证数据库中数据的正确性、有效性和完整性。</font>

3. 分类

   | 约束                      | 描述                                                     | 关键字       |
   | ------------------------- | -------------------------------------------------------- | ------------ |
   | 非空约束                  | 限制该字段的数据不能为 null                              | NOT NULL     |
   | 唯一约束                  | 保证该字段的所有数据都是唯一、不重复的                   | UNIQUE       |
   | 主键约束                  | 主键是一行数据的唯一标识，要求非空且唯一                 | PRIMIARY KEY |
   | 默认约束                  | 保存数据时，如果未能指定该字段的值，则采用默认值         | DEFAULT      |
   | 检查约束(8.0.16 版本之后) | 保证字段值满足某一个条件                                 | CHECK        |
   | 外键约束                  | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY  |

   <font color="red">注意：约束是作用在表中字段的，可以在创建表 / 修改表的时候添加约束。</font>

## 5.2 常见外键

   案例：根据需求，完成 user 表结构的创建

   | 字段名 | 字段含义    | 字段类型    | 约束条件                               |
   | ------ | ----------- | ----------- | -------------------------------------- |
   | id     | ID 唯一标识 | int         | 主键，并且**自动增长**(auto_increment) |
   | name   | 姓名        | varchar(10) | 不为空，并且唯一                       |
   | age    | 年龄        | int         | 大于0，并且小于等于120                 |
   | status | 状态        | char(1)     | 如果没有指定该值，默认为1              |
   | gender | 性别        | char(1)     | 无                                     |

>  注意：当我们设置  auto_increment 时，一定要同时为这个属性设置为 primary key  

测试代码如下：

   ```mysql
   -- 建立用户表
   create table user(
       id int primary key auto_increment comment '主键',
       name varchar(10)  not null unique comment '姓名',
       age int check (age > 0 && age <=120),
       status char(1) default '1' comment '状态',
       gender char(1) comment '性别'
   ) comment '用户表';
   
   -- 插入数据
   insert into user(name,age,status,gender) values('Tom1',19,'1','男');
   insert into user(name,age,status,gender) values('Tom2',19,'1','男');
   insert into user(name,age,status,gender) values('Tom3',19,'1','男');
   insert into user(name,age,status,gender) values('Tom4',19,'1','男');
   ```

这时候我们查看执行结果：

![image-20220819203518697](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819203518697.png)

这时如果我们继续执行：

```mysql
insert into user(name,age,status,gender) values('Tom4',19,'1','男');
```

此时由于 name 已经设置了唯一约束，所以插入失败，但主键设置了 auto_increment ,此时主键仍然会申请一个 id，我们再次插入一个有效的数据会发现，新插入的数据的 id 变为了6

```mysql
insert into user(name,age,status,gender) values('Tom5',19,'1','男');
```

![image-20220819203931415](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819203931415.png)

由此我们可以知道：<font color="red">唯一索引不受主键自增的约束</font>

## 5.3 外键约束

概念：外键用来让两张表的数据之间建立连接，从而<font color="red">保证数据的一致性和完整性。</font>

用外键关联起来的两张表我们分别称之为主表(父表)和从表(子表)

- 具有外键的表：从表(子表)
- 外键所关联的表：主表(父表)

示例：

```mysql
-- 准备数据
create table dept(
    id int auto_increment comment 'ID' primary key,
    name varchar(10) not null comment '部门名称'
) comment '部门表';

insert into dept(id,name) values(1,'研发部'),(2,'市场部'),(3,'销售部'),(5,'总经办');

create table emp(
    id int auto_increment comment 'ID' primary key,
    emp_name varchar(50) not null comment '姓名',
    age tinyint unsigned check(age>0 && age<=120),
    job varchar(20) comment '职位',
    salary int comment '薪资',
    entry_date date  comment '入职时间',
    manager_id int comment '直属领导ID',
    dept_id int comment '部门ID'
)comment '员工表';

insert into emp(id,emp_name,age,job,salary,entry_date,manager_id,dept_id) values(1,'金庸',66,'总裁',20000,'2000-01-01',null,5);
insert into emp(id,emp_name,age,job,salary,entry_date,manager_id,dept_id) values(2,'张无忌',20,'项目经理',12500,'2002-12-05',1,1);
insert into emp(id,emp_name,age,job,salary,entry_date,manager_id,dept_id) values(4,'韦一笑',48,'开发',11000,'2002-02-05',2,1);
insert into emp(id,emp_name,age,job,salary,entry_date,manager_id,dept_id) values(3,'杨逍',33,'开发',8400,'2003-11-03',2,1);
insert into emp(id,emp_name,age,job,salary,entry_date,manager_id,dept_id) values(5,'常遇春',43,'开发',10500,'2004-09-07',3,1);
insert into emp(id,emp_name,age,job,salary,entry_date,manager_id,dept_id) values(6,'蒋仁杰',19,'程序员鼓励师',6600,'2004-10-12',2,1);

```

==但是上述操作并未建立起表 emp 和表dept 之间的关系，无法保证据数据的一致性和完整性==

### 添加外键

这个时候就需要我们来添加外键，语法格式如下：

```mysql
CREATE TABEL 表名(
	字段名 数据类型
	…
	[constraint][外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)
)
```

```mysql
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);
```

我们首先分析：dept 应该作为主表，而 emp 作为从表，外键是 部门ID，所以我们添加外键时，应该这么写：

```mysql
alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);
```

之后我们查看 emp 表，发现 dept_id 旁边有一个蓝色的钥匙图标

![image-20220819224908492](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819224908492.png)

（<font color="red">在 datagrip 中黄色钥匙代表的是主键，蓝色钥匙代表的是外键）</font>



### 删除外键

语法格式如下：

```mysql
ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
```



## 5.4 外键删除和更新行为

| 行为        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| NO ACTION   | 当在父表中删除 / 更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除 / 更新(与 RESTRICT 一致) |
| RESTRICT    | 当在父表中删除 / 更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除 / 更新(与 NO ACTION 一致) |
| CASCADE     | 当在父表中删除 / 更新对应记录时，首先检查该记录是否有对应外键，如果有，则也删除外键在字表中的记录 |
| SET NULL    | 当在父表中删除对应记录时，首先检查该记录是否有对应外键，如果有则设置字表中该外键值为 null（这就要求该外键允许取 null） |
| SET DEFAULT | 父表有变更时。字表将外键列设置成一个默认值(Innodb 不支持)    |

> NO ACTION 和 RESTRICT 都是mysql 默认的行为

更改外键的修改规则：

```mysql
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字符) REFERENCES 主表名(主表字段) ON UPDATE rule ON DELETE rule;
```

> 这里的 rule 指的是上面的5中规则

我们还可以借助 DataGrip 来更改外键的修改规则

第一步，右键想要修改的表的名称，选择 Modify Table

![image-20220819232532638](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819232532638.png)

第二步，找到外键一栏，双击即可

![image-20220819232703175](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819232703175.png)

第三步，滑动到最下面，找到更新和删除规则即可

![image-20220819232807659](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220819232807659.png)



# 6 多表查询

## 6.1 多表关系

项目开始中，在进行数据库结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也会存在着各种联系，基本分为三种：

- 一对多（多对一）
- 多对多
- 一对一



### 6.1.1 一对多

案例：部门与员工之间的关系

关系：一个部门可以对应多个员工，但一个员工只能对应一个部门

实现：<font color="red">在多的一方建立外键，指向一的一方的主键</font>

![一对多](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/%E4%B8%80%E5%AF%B9%E5%A4%9A.jpg)



### 6.1.2 多对多

案例：学生与课程的关系

关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择

实现：<font color="red">建立第三章中间表，中间表中至少包含两个外键，分别关联两方主键</font>



### 6.1.3 一对一

案例：用户与用户详情之间的关系

关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升效率

实现：<font color="red">在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</font>



## 6.2 多表查询概述

在之前已经准备好 emp 和 dept 两张表，现在我们基于之前准备好的两张表来进行练习

概述：是从多张表中查询数据

笛卡尔积：笛卡尔积是指在数学中，两个集合 A 和集合 B 的所有组合情况（$A \times B$）。（<font color="red">在多表查询时，需要消除无效的笛卡尔积</font>）

多表查询的分类：

1. 连接查询

- 内连接：相当于查询 A、B 的交集部分
- 外连接：
  - 左外连接：查询<font color="red">左表</font>所有数据，以及两张表的交集部分数据
  - 右外连接：查询<font color="red">右表</font>所有数据，以及两张表交集部分的数据
- 自连接：当前表与自身的连接查询，<font color="red">自连接必须使用表别名</font>

2. 子查询

![mysql-连接](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/mysql-%E8%BF%9E%E6%8E%A5.jpg)

## 6.3 内连接

隐式内连接

```mysql
SELECT 字段列表 FROM 表1,表2 WHERE 条件…;
```

显式内连接

```mysql
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件…;
```



内连接演示：

```mysql
-- 1. 查询每个员工的姓名以及关联的部门名称(隐式内连接实现)
select e.emp_name,d.name from emp e,dept d  where e.dept_id = d.id;
-- 在多表查询中，通常会使用表的别名来简化 sql 语句
-- 如果我们给表取了别名，那就不能再直接通过表名来限制字段

-- 2.查询每个员工的姓名以及关联的部门名称(显式内连接实现)
select e.emp_name,d.name from emp e inner join dept d on e.dept_id = d.id;
```



## 6.4 外连接

左外连接

```mysql
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;
```

右外连接

```mysql
SLEECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;
```

演示如下：

```mysql
-- 左外连接
select emp.*, dept.name from emp left outer join dept on emp.dept_id = dept.id;

-- 右外连接
select emp.*,dept.name from emp right outer join dept on emp.dept_id = dept.id;
```



## 6.5 自连接

自连接查询语法：

```mysql
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件;
```

<font color="red">自连接查询，可以是内连接查询，也可以是外连接查询</font>

演示如下：

```mysql
-- 1.查询员工及所属领导的姓名
select a.emp_name,b.emp_name from emp a,emp b where a.manager_id = b.id;

-- 2.查询所有员工 emp 及其领导的姓名 emp，如果员工没有领导，也需要查询出来
select a.emp_name,b.emp_name from emp a left join emp b on a.manager_id = b.id;
```



## 6.6 联合查询

对于 union 查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。

```mysql
SELECT 字段列表 FROM 表A
UNION [ALL]
SELECT 字段列表 FROM 表B;
```

```mysql
-- 将薪资低于 5000 的员工和年龄大于 50 的员工全部查询出来
select * from emp where salary < 5000
union all
select * from emp where age > 50;

-- 将上述案例的查询结果进行去重
select * from emp where salary < 5000
union
select * from emp where age > 50;
```

- <font color="red">对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致</font>
- <font color="red">union all 会将全部的数据直接合并在一起， union 会对合并之后的数据去重</font>



## 6.7 子查询

概念： SQL 语句中嵌套 SELECT 语句，成为==嵌套查询==，又称为==子查询==

```mysql
SELECT * FROM t1 WHERE column1=(SELECT column1 FROM t2);
```

<font color="red">子查询外部的语句可以是 INSERT / UPDATE /DELETE / SELECT 的任何一个</font>

根据子查询的结果不同，分为：

- 标量子查询(子查询结果为单个值)
- 列子查询(查询结果为一行)
- 行字查询(子查询结果为一行)
- 表子查询(子查询结果为多行多列)

根据子查询的位置，分为：

- WHERE 之后
- FROM 之后
- SELECT 之后



### 6.7.1 标量子查询

子查询返回的结果是单个值(数字、字符串、日期等)，最简单的形式，这种查询称为<font color="red">标量子查询</font>

常用的操作符： `=`、` <>`、` >`、` >=`、` <`、` <=`

演示如下：

```mysql
-- 标量子查询
-- 查询"销售部"的所有员工信息
select * from emp where dept_id = (select id from dept where name='销售部');

-- 查询"房东白"入职之后的员工信息
select * from emp where entry_date > (select entry_date from emp where emp_name='方东白');
```



### 6.7.2 列子查询

子查询的返回结果是一列（可以是多行），这种子查询称为<font color="red">列子查询</font>

常用的操作符：`IN`、`NOT IN`、`ANY`、`SOME`、`ALL`

| 操作符 | 描述                                        |
| ------ | ------------------------------------------- |
| IN     | 在指定的集合范围之内，多选一                |
| NOT IN | 不在指定的集合范围之内                      |
| ANY    | 子查询返回列表，有任意一个满足即可          |
| SOME   | 与 ANY 等同，使用 SOME 的地方都可以使用 ANY |
| ALL    | 子查询返回列表的所有值都必须满足            |

演示如下;

```mysql
-- 列子查询
-- 1.查询"销售部" 和 "市场部"的所有员工信息
select * from emp where dept_id in (select id from dept where name='销售部' or name='市场部');

-- 2.查询比财务部所有人工资都高的员工信息
select * from emp where salary > all(select salary from emp where dept_id =(select id from dept where name='销售部'));

-- 3. 比研发部任意员工工资高的员工信息
select * from emp where salary > any(select salary from emp where dept_id =(select id from dept where name='研发部'))
```

### 6.7.3 行子查询

子查询返回的结果是一行（可以是多列），这种子查询称为<font color="red">行子查询</font>

常用的操作符：`=`、`<>`、`IN`、`NOT IN`

```mysql
-- 行子查询
-- 查询与张无忌的薪资和领导相同的员工信息
select * from emp where (salary, manager_id) = (select salary, manager_id from emp where emp_name='张无忌');
```

### 6.7.4 表子查询

子查询返回的结果是多行多列，这种子查询称为<font color="red">表子查询</font>

常用的操作符：`IN`

```mysql
-- 表子查询
-- 1. 查询与"鹿杖客","宋远桥" 的职位和薪资相同的员工信息
select * from emp where (job,salary) in (select job,salary from emp where emp_name='鹿杖客' or emp_name='宋远桥');

-- 2.查询入职日期是"2006-01-01"之后的员工信息，及其部门信息
-- a.入职时间是"2006-01-01"之后的员工信息
select * from emp where entry_date > '2006-01-01';

-- b.查询这部分员工对应的部门的信息
select e.*,d.name from (select * from emp where entry_date > '2006-01-01') e left join dept d on e.dept_id = d.id;
```



### 6.7.5 案例（p48-p50)





# 7 事务

## 7.1 事务简介

事务用于<strong style="color:red">保证数据的一致性</strong>，它由一组相关的 DML 语句组成，该组的 DML 语句要么全部成功，要么全部失败。最典型的业务场景就是转账：

![image-20220820151522071](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820151522071.png)

<font color="red">注意：默认 MySQL 事务是自动提交的，也就是说，当执行一个 DML 语句，MySQL 会立即隐式地提交事务</font>



## 7.2 事务操作

:herb:**事务和锁**

当执行事务操作时（DML 语句），MySQL 会在表上加锁，防止其它用户改表的数据，这对用户而言是十分重要的。

事务的基本操作如下：

1. 开启事务

   ```mysql
   start transaction; 或 begin;
   ```

2. 设置保存点

   ```mysql
   savepoint 保存点名
   ```

3. 回滚事务

   ```mysql
   rollback to 保存点名
   # 或
   rollback	-- 回退全部事务
   ```

4. 提交事务

   ```mysql
   commit	-- 一旦提交事务，所有操作生效，且不能回滚
   ```

5. 查看事务的提交方式

   ```mysql
   SELECT @@autocommit;
   ```

6. 设置事务的提交方式

   ```mysql
   SET @@autocommit = 0;	-- 设置为手动提交，如果为 1 表示自动提交
   # 第二种方式
   set autocommit = off;
   ```



**示例**

```mysql
# 模拟事务
use test_db;
-- 事先创建一张测试表
CREATE TABLE customer(
    id INT PRIMARY KEY,
    `name` VARCHAR(32) NOT NULL,
    deposit DECIMAL(18, 2)
);
INSERT INTO customer VALUES(1, 'Tom', 3000.00);
INSERT INTO customer VALUES(2, 'Bob', 4500.00);
-- 查看事务提交方式
select @@autocommit;
-- 修改为手动提交
set @@autocommit = 0;
-- 开启事务
start transaction;

savepoint a;
UPDATE customer set deposit = deposit - 1000 WHERE id = 1;

savepoint b;
UPDATE customer set deposit = deposit + 1000 WHERE id = 2;

-- 先回退到 b
rollback to b;

-- 继续回退到 a
rollback to a;

-- 提交
commit;

select * from customer;
```



:small_red_triangle:**事务的注意事项**

1. 当我们使用 commit 提交事务或者 rollback 回滚事务后，前面的保存点都会被删除掉
2. 使用 commit 提交事务后，数据库会执行流程如下：确认事务的变化 → 结束事务 → 删除保存点 → 释放锁 → 数据生效
3. 默认情况下，MySQL 的事务是自动提交的，我们需要手动设置，将其修改为手动提交
4. MySQL 的事务机制需要 Innodb 的存储引擎才可以使用，myisam 不好使



## 7.3 事务的四大特性ACID

- 原子性(<font color="red">A</font>tomicity)：事务是不可分割的最小操作单元
- 一致性(<font color="red">C</font>onsistency)：事务完成时，必须使所有的数据都保持一致状态
- 隔离性(<font color="red">I</font>solation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
- 持久性(<font color="red">D</font>urablity)：事务一旦提交或回滚，他对数据库中的数据的改变就是永久的

> - 一致性举例：在转账过程中，转账双方的金额总数是不会发生改变的
> - 隔离性详解：每个事务是处在一个独立的环境中事务与事务之间是不会相互影响的



## 7.4 并发事务问题

| 问题                             | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| 脏读（dirty read）               | 一个事务读到另外一个事务尚未提交的改变，读取的是为提交的事务 |
| 不可重复读（nonrepeatabel read） | 同一查询在同一事务中多次进行，由于其他提交事务所做的<strong style="color:red">更新</strong>，导致每次查询读取的数据不一致 |
| 幻读（phantom read）             | 同一查询在同一事务中多次进行，由于其他提交事务所做出的的<strong strong style="color:red">添加或删除操作</strong>，导致每次读取的数据量不同^？^，发生幻读 |

**脏读示例：**

![脏读](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/%E8%84%8F%E8%AF%BB.jpg)

左边的事务A 先对 id=1 的行做出查询后更新，但此时A还没完成第三步的提交事务，而<font color='red'>右边的事务B却读取的A未提交的内容</font>，导致读取的内容有误，这便是==脏读==，脏读一般而言是针对 UPDATE的

**不可重复读示例：**

![mysql-不可重复读](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/mysql-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.jpg)

左边的事务A在第一次查询之后，第二次查询之前，右边的事务A完成了提交，数据库中的数据发生改变，之后A第二此查询发现数据出现不一致

**幻读示例：**

![](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6-%E5%B9%BB%E8%AF%BB.jpg)

左边的事件A开始查询 id=1 的数据发生不存在 id=1 的数据，准备插入 id=1 的数据，但是右边的事务B 却抢先插入导致A 插入失败，等B事务回滚后，再次查询 id=1 的数据发现还是没有，这就形成了一种"幻觉"



## 7.5 事务的隔离级别

多个连接开启各自事务操作数据库中的数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性。

如果不考虑隔离性，则会引发如下问题：

1. 脏读
2. 不可重复读
3. 幻读

MySQL 隔离级别<strong style="color:red">定义了事务与事务之间的隔离程度</strong>

|          隔离级别          | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| :------------------------: | :--: | :--------: | :--: | ------ |
| Read uncommitted(读未提交) |  √   |     √      |  √   | 不加锁 |
|  Read committed(读已提交)  |  ×   |     √      |  √   | 不加锁 |
| Repeatable Read(可重复读)  |  ×   |     ×      |  √   | 不加锁 |
|   Serializable(可串行化)   |  ×   |     ×      |  ×   | 加锁   |

> 这四种隔离级别从上到下：<font color="red">隔离级别越来越高，并发性能越来越差</font>
>
> mysql 中默认的隔离级别是 Repeatable Read，而在 Oracle 中默认的隔离级别是 Read committed
>
> - 禁止写时读，避免了 "脏读"，对应隔离级别 read committed
> - 禁止读时写，避免了 "不可重复读"，对应隔离级别 repeatable read
> - 避免“幻读”，干脆把整个表给锁住了，只能是 serialize

**查看事务隔离级别**

```mysql
SELECT @@TRANSACTION_ISOLATION;
```

**设置事务隔离级别**

```mysql
SET [SESSION | GLOBAL] TRANSACTION ISAOLATION LEVEL {READ UNCOMMITTED | READ COMMITED | REPEATABLE READ | SERIALIZABLE};
```

演示如下：

![image-20220820201707411](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820201707411.png)

右侧事务还未提交，左侧事务就已经得到右侧事务提交的数据，称为脏读

![image-20220820202638391](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820202638391.png)

右侧事务提交后，左侧数据发生改变，称为不可重复读

![image-20220820204555979](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820204555979.png)

我们可以看到如果将隔离级别修改为 Repeatable Read，这时如果我们在右侧事务 B 中插入数据并提交后，在左侧事务 A 看到无 id=3 的数据，但无法插入数据，并且再次查询时发现 id=3 为的数据还是空，这就给人一种"幻觉"，这便称为"幻读"

<font color="red">注意：事务隔离级别越高，数据越安全，但性能越低。</font>



# 8 存储引擎

MySQL 体系结构

![image-20220820210154690](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820210154690.png)

- 连接层
  最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
- 服务层
  第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。
- 引擎层
  存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要来选取合适的存储引擎。
- 存储层
  主要是将数据存储在文件系统之上，并完成与存储引擎的交互。

## 8.1 存储引擎简介

存储引擎就是存储数据\建立索引、更新 / 查询数据等技术的实现方式。<font color="red">存储引擎是基于表的</font>，而不是基于库的，所以<font color='red'>存储引擎也可被称为表类型。</font>

**查询建表语句**

```mysql
SHOW CREATE TABLE 表名;
```

示例：

![image-20220820221826637](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820221826637.png)

**查看当前数据库支持的存储引擎**

```mysql
show engines;
```

示例：

```mysql
-- 创建表 my_MyISAM,指定 MyISAM 的存储引擎
create table my_MyISAM(
    id int,
    name varchar(10)
)engine=MyISAM;

-- 创建表 my_Memory，指定 Memory 存储引擎
create table my_Memory(
    id int,
    name varchar(10)
)engine=MEMORY;
```

我们在 DataGrip 中可以使用快捷键 Ctrl + B 直接打开建表语句，查看其引擎，如下图：

![image-20220820223106077](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820223106077.png)



## 8.2 存储引擎特点

### 8.2.1 InnoDB 

InnoDB：是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 存储引擎。

InnoDB 特点：

- DML 操作遵循 ACID 模型，支持==事务==；
- ==行级锁==，提高并发访问性能
- 支持==外键== FOREIGN KEY 约束，保证数据的完整性和正确性

Innodb 文件：

xxx.ibd：xxx代表的是表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm、sdi)、数据和索引

参数：`innodb_file_per_table`

在 MySQL 中，我们可以通过指定的 SQL 语句来查看变量：

```mysql
show variables like '参数'
```

我们使用 `show variables like 'innodb_per_table'`来查看，会发现 MySQL 中这个每张表对应一个 innodb 文件默认是打开的：

![image-20220820230532012](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820230532012.png)

![image-20220820230938115](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820230938115.png)

在这个 .ibd 文件中存放着当前数据库的==表结构、数据和索引==

我们想要打开该文件，可以打开 cmd，在命令行中输入：

```bash
ibd2sdi ibd文件
```

示例：

![image-20220820231343280](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220820231343280.png)



**InnoDB 的逻辑存储结构如下：**

![InnoDb 存储结构](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/InnoDb%20%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpg)

一个区的大小是固定的，为 1M ，一页的大小也是固定的，为 16K，也就是说一个区可以容纳 64 个页。



### 8.2.2 MyISAM 

介绍

MyISAM 是 MySQL 早期的默认存储引擎

特点

- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

文件

- xxx.sdi：存储表结构信息
- xxx.MYD：存储数据
- xxx.MYI：存储索引



### 8.2.3 MEMORY 

介绍

MEMORY 引擎的表数据是存储在内存中的，由于收到硬件问题或断电影响，只能将这些表作为临时表或缓存使用

特点

- 内存存放
- hash 索引(默认)

文件

xxx.sdi：存储表结构信息



## 8.3 存储引擎选择

在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。

- InnoDB：是MysqI的默认存储引擎，==支持事务、外键。如果应用对事务的完整性有比较高的要求==，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。
- MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。
- MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。



# 9 索引

## 9.1 Linux 中 MySQL 的安装

### 9.1.1.使用 Mobaxterm 连接虚拟机

:bell:解决 centOS 中没有出现 ens33 网卡的解决方案：

可能是 CentOS 图形管理中的 NetworkManager 接管了网络配置，执行以下命令即可恢复：

```shell
systemctl stop NetworkManager                             临时关闭
systemctl disable NetworkManager                          永久关闭网络管理命令
systemctl start network.service                           开启网络服务
```

解决好网卡问题，我们直接来进入正题：

打开 CentOS ， 打开终端，输入 `ifconfig`，找到 ens33 网卡下的 inet ，复制 host

![image-20220821005535328](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821005535328.png)

打开 SSH 会话，输入 host 和用户名即可完成连接

![image-20220821005803447](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821005803447.png)

### 9.1.2.MySQL 8.0.26 -Linux 版安装

所使用的 Linux 型号为 CentOS 7

点击官网地址，[:point_right:](https://downloads.mysql.com/archives/community/)

![image-20220821131745322](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821131745322.png)

### 9.1.3 上传 MySQL 安装包

直接拖动即可

![image-20220821134930235](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821134930235.png)

### 9.1.4 创建目录并解压

```shell
mkdir mysql
```

```shell
tar -xvf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar -C mysql
```

之后进入 mysql 目录下查看解压好的包

### 9.1.5 安转 MySQL 的安装包

```shell
cd mysql

rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm	--nodeps --force

rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm --nodeps --force

rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm --nodeps --force

rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm --nodeps --force

rpm -ivh mysql-community-devel-8.0.26-1.el7.x86_64.rpm --nodeps --force

# 依赖下载完成之后，我们接着需要安装客户端和服务端

rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm --nodeps --force

rpm -ivh mysql-community-server-8.0.26-1.el7.x86_64.rpm --nodeps --force

```

如果出现依赖检测失败，如下图：

![image-20220821140733855](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821140733855.png)

可以使用命令 `yum install openssl-devel`下载依赖

### 9.1.6 启动MySQL

```shell
systemctl start mysqld		# 启动 MySQL 服务
```

```shell
systemctl restart mysqld	# 重启 MySQL 服务
```

```shell
systemctl stop mysqld		# 停止 MySQL 服务
```



### 9.1.7 查询自动生成的 root 用户密码

```shell
grep 'temporary password' /var/log/mysqld.log
```

查询到 mysql 自动生成的临时密码，如下：

![image-20220821141355726](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821141355726.png)

命令行执行指令：

```shell
mysql -u root -p
```

然后输入查询的密码即可

![image-20220821141846634](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821141846634.png)

> 注意：在 Linux 中密码默认是不显示的，所以直接选中密码再右键，敲回车便可登录成功

### 9.1.8 修改密码

登录到 MySQL 之后，需要将自动生成的不便记忆的密码修改成自己熟悉的便于记忆的密码

```mysql
ALTER USER 'root'@'localhost' IDENTIFIED BY '1234';
```

![image-20220821143338001](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821143338001.png)

但执行上述的 SQL 会报错，原因是 Linux 中有一个密码校验的插件，会默认要求密码至少是中等级别强度，<font color="red">需求为长度不少于8位，包含字母大小写和特殊字符</font>

所以我们可以设置密码的复杂度为简单类型

```mysql
set global validate_password.policy = 0;
set global validate_password.length = 4;
```

降低安全等级之后，我们执行第一条指令，设置登录密码为 1234

退出 `exit;`，重新登录

### 9.1.9 创建用户

默认的 root 用户只能在当前节点 localhost 访问，无法远程访问，为了能使得我们在 Windows 中的 Datagrip 也可以使用，我们需要创建一个 root 用户，用于远程访问。

```mysql
create user 'root'@'%' IDENTIFIED WITH mysql_native_password BY '1234';
```

分配 root 用户权限

```mysql
grant all on *.* to 'root'@'%';
```

### 9.1.10 在 DataGrip  中登录 Linux 中的 MySQL

我们首先需要在自己的 Linux 中关闭自己的防火墙或给自己的防火墙添加端口号:3306

关闭防火墙：

```shell
systemctl stop firewalld.service
```

但是这样做，==重启后，防火墙又会重新打开==

回到 DataGrip 中创建数据源

![image-20220821144849035](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821144849035.png)

输入 host 地址和 密码，注意下面的 url 一定要更改：

![image-20220821150315636](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821150315636.png)

> host 地址要自己在 linux 中输入 `ifcofig`来查看 host 



## 9.2 索引概述

索引（index) 是帮助 MySQL <font color="red">高效获取数据</font>的<font color="red">数据结构</font>

演示如下：

![image-20220821160056794](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821160056794.png)

优点：

- 提高数据检索的效率，降低数据库的 IO 成本
- 通过索引对数据进行排序，降低数据排序成本，降低 CPU 的消耗

缺点：

- 索引列需要占用空间
- 索引大大提高了查询效率，同时却也降低了更新表的速度，如对表进行 INSERT 、UPDATE 、DELETE 操作时，效率会降低

## 9.3 索引结构

MySQL 的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：

| 索引结构                             | 描述                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| <font color="red">B+Tree 索引</font> | <font color="red">最常见的索引类型，大部分引擎都支持 B+ 树索引</font> |
| Hash 索引                            | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才会有效，不支持范围查询 |
| R-tree(空间索引)                     | 空间索引是 MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引)                  | 是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene,Solr,Es |

支持情况：

| 索引        | InnoDB           | MyISAM | Memory |
| ----------- | ---------------- | ------ | ------ |
| B+tree 索引 | 支持             | 支持   | 支持   |
| Hash 索引   | 不支持           | 不支持 | 支持   |
| R-tree 索引 | 不支持           | 支持   | 不支持 |
| Full-text   | 5.6 版本之后支持 | 支持   | 不支持 |

<font color='red'>我们平常所说的索引，如果没有特别指明，都是值 B+ 树结构组织的索引结构</font>

我们首先引入二叉树

![image-20220821162443956](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821162443956.png)

<font color="red">二叉树的缺点：顺序插入时，会形成一个链表，查询性能会大大降低。因此在大量数据情况下，层级较深，检索速度慢</font>

![image-20220821163731326](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821163731326.png)

<font color="red">红黑树：大数据量情况下，层级较深，检索速度慢</font>

## 9.4 B-Tree(多路平衡查找树)

以一颗最大度数（max-degree）为5（5阶）的b-tree为例（每个节点最多存储 4 个 key ，5 个指针）：

![image-20220821174748290](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821174748290.png)

B-tree 的演变过程可以通过演示网址去训练，摸透原理，参考：[点击这里](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)

其演变规律为：<font color="red">超过5个指针，中间元素向上分裂</font>

## 9.5 B+ tree

以一颗最大度数(max-degree) 为4(4 阶)的 B+ tree 为例：

![image-20220821180649443](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821180649443.png)

B+ 树 和 B 树的不同之处在于：

- 所有的数据都存放在叶子节点，其他节点都是充当索引
- 叶子节点会形成一个单向链表

<font color='red'>演变规律：以最大度数为5示例：指针超过5，中间向上裂变并拷贝数据在右子树</font>



MySQL 索引数据结构经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高了区间访问的性能。

最终完成形态如下:

![image-20220821182145146](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821182145146.png)

## 9.6 Hash 索引结构

哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位，然后存储在 hash 表中

如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了==hash 冲突==（也称为 hash 碰撞），可以通过链表来解决。

Hash 索引特点：

- Hash 索引只能用于对等比较（=，in）,不支持范围查询（between，>, <…）
- 无法利用索引完成排序操作
- 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+ Tree 索引

存储引擎支持：

在 MySQL 中，支持 hash 索引的是==MEMORY 引擎==，而 InnoDB 中具有自适应 Hash 功能，Hash 索引是存储引擎根据 B+ Tree 索引在指定条件下自动构建的。



## 9.7 面试题：为什么 InnoDB 采用B+树？

- 相对二叉树，层级更少，搜索效率高
- 对于 B-tree ，无论是叶子节点还是非叶子节点，都会保留数据，这就导致一页中存储的键值减少指针跟着减少，要同样保存大量数据，就只能增加树的高度，导致性能下降:question:
- 相对 Hash 索引， B+ Tree 支持范围匹配及排序操作

| 分类     | 含义                                                 | 特点                     | 关键字   |
| -------- | ---------------------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的重复值                     | 可以有多个               | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个               |          |
| 全文索引 | 全文索引查找的是文本中的关键字，而不是比较索引中的值 | 可以有多个               | FULLTEXT |

> 在开发过程中，一般不使用 mysql 自带的全文索引，而是使用：Solr 和 ElasticSearch（ES）

在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类                       | 含义                                                       | 特点                 |
| -------------------------- | ---------------------------------------------------------- | -------------------- |
| 聚集索引（Clustered Index) | 将数据存储与索引放在一块，索引结构的叶子节点保存了行数据   | 必须有，而且只有一个 |
| 二级索引（Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |

聚集索引的存储规则：

- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引
- 如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引

![image-20220821201404611](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821201404611.png)

> 回表查询：先从二级索引中找到主键值，在根据主键值去找到这一行的行数据



**思考：InnoDB主键索引的 B+ Tree 高度有多高？**

一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。
如果高度为2：

$n \times 8+（n+1）\times 6=16 \times 1024$，算出$n  \approx 1770$

$1171 \times 16=18736$
如果高度为3：

$1171 \times 1171 \times 16 = 21939856$

可以看出，即使数据量达到了200多万， B+树仍然只有3层，这样的效率是非常高的



## 9.8 索引的语法

- 创建索引

  ```mysql
  CREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name (index_col_name,…);
  
  # 添加主键索引
  ALTER TABLE 表名 ADD PRIMARY KEY(列名, ...)
  
  # 添加普通索引
  ALTER TABLE table_name INDEX index_name(index_col_name)
  ```

  > 如果一个字段关联一个索引我们称为单列索引，如果一个字段关联多个索引我们称之为联合索引

- 查看索引

  ```mysql
  SHOW INDEX FROM table_name;
  ```

- 删除索引

  ```mysql
  DROP INDEX index_name ON table_name;
  
  # 删除主键索引
  ALTER TABLE table_name DROP PRIMARY_KEY;
  ```

演示：

在Mobaxterm 连接上 Linux 的 mysql

准备数据:

```mysql
-- 创建数据库 itcast
create database itcast;
-- 设置当前数据库
use itcast;
-- 建表
create table tb_user(
    id int primary key auto_increment comment'主键ID',
    user_name varchar(10) comment '姓名',
    phone char(11)  comment '电话',
    email varchar(50) comment '邮件',
    profession varchar(10) comment '专业',
    age tinyint unsigned comment '年龄',
    gender char(1) comment '性别',
    user_status char(1) comment '状态',
    create_time varchar(50) comment '创建时间'
)comment '用户表';

-- 插入数据

insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('吕布','1779999001','lvbu666@qq.com','软件工程',20,'男','2','2022-10-08 12:12:12');
insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('貂蝉','1779999002','diaochan666@163.com','园林艺术',19,'女','7','2022-10-08 12:12:12');
insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('程咬金','1779999003','chenyao666@gmail.com','软件工程',20,'男','8','2022-10-08 12:12:12');
insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('安琪拉','1779999004','angle666@qq.com','软件工程',21,'男','2','2022-10-08 12:12:12');
insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('李白','1779999005','libai666@qq.com','软件工程',20,'男','1','2022-10-08 12:12:12');
insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('哪吒','1779999006','nazhai666@gmail.com','软件工程',19,'男','5','2022-10-08 12:12:12');
insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('梦琪','1779999007','mengqi666@outlook.com','软件工程',20,'男','8','2022-10-08 12:12:12');
insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('孙尚香','1779999008','sunshang666@qq.com','软件工程',22,'男','4','2022-10-08 12:12:12');
insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('八神庵','1779999009','baba666@foxmail.com','软件工程',20,'男','3','2022-10-08 12:12:12');
insert into tb_user(user_name,phone,email,profession,age,gender,user_status,create_time) values('可莉','1779999010','lovely666@1634.com','软件工程',18,'男','1','2022-10-08 12:12:12');
```

按照下列的需求，完成索引的创建

1. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。
2. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。

3. 为profession、age、status创建联合索引。
4. 为email建立合适的索引来提升查询效率。

首先我们查看新建的表，发现只有一个索引，即 PRIMARY

![image-20220821224032032](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821224032032.png)

> 注意：这里显示的索引类型虽然是 B 树，但其实是因为 B+ 树是 B 树的变种，这里其实指的是 B+ 树

这里显示的错位了，为了使得看起来更加工整，我们可以使用下面的命令来使得显示得更加工整：

```mysql
show index from tb_user\G;
```

![image-20220821225003838](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821225003838.png)

```mysql
-- 1. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。
create index idx_user_name on tb_user(name);
-- 2. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。
create unique index idx_user_phone on tb_user(phone);
-- 3. 为profession、age、status创建联合索引。
create index idx_pas on tb_user(profession,age,user_status);
-- 4. 为email建立合适的索引来提升查询效率。
create index idx_uer_email on tb_user(email);
```



## 9.9 SQL 性能分析工具的介绍

### 9.9.1 SQL 执行评率

通过如下指令，我们可以查看当前数据库的 INSERT 、UPDATE、DELETE、SELECT 的访问频次：

```mysql
SHOW [GLOBAL | session] STATUS LIKE 'Com___';
```

> 一个下划线 "_" 代表一个字符

演示如下：

![image-20220821230658891](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821230658891.png)

> 注意：Com 后面有七个下划线"_"，我们可以通过如上图查看到全部会话的各个语句执行频次



### 9.9.2 慢查询日志

慢查询日志记录了<font color='red'>所有执行事件超过指定参数（long_query_time，单位：秒，默认10秒）</font>的所有 SQL 语句的日志。

MySQL 的慢查询日志默认没有开启，需要在 MySQL 的配置文件(/etc/my.cnf)中配置如下信息。

首先，查看配置慢查询日志是否开启：

```mysql
show variables like 'slow_query_log';
```

![image-20220821233425301](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821233425301.png)

再来文件 ( /etc/my.cnf ) 配置如下信息：

```mysql
# 开启 MySQL 慢日志查询开关
slow_query_log = 1

# 设置慢日志的时间为 2s，SQL 语句的执行时间超过 2s，就会被视为慢查询，记录在慢查询日志中
long_query_time = 2
```

配置完毕后，通过以下指令重新启动 MySQL 服务器进行测试，查看慢日志文件中记录的信息 `/var/lib/mysql/localhost-slow.log`

```shell
systemctl restart mysqld
```

重启后再来查询慢表

![image-20220821235245828](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821235245828.png)

![image-20220821235908895](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220821235908895.png)

### 9.9.3 profiles 详情

`show_profiles` 能够在做 SQL 优化时帮助我们了解时间都耗费到哪里去了。通过 `have_profiling` 参数，能够看到当前 MySQL是否支持 profile 操作:

```mysql
SELECT @@have_profiling;
```

默认 profiling 是关闭的，可以通过 set 语句在 session/global 级别开启 profiling

```mysql
SET profiling = 1;
```

![image-20220822001729066](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822001729066.png)

我们可以通过下面的命令来查看 sql 的耗时情况

```mysql
# 查看每一条 SQL 的耗时基本情况
show profiles;

# 查看指定 query_id 的 SQL 语句各个阶段的耗时情况
show profile for query.query.id;

# 查看指定 query_id 的 SQL 语句 CPU 使用情况
show profile cpu for query.query_id;
```

演示如下：

![image-20220822002644978](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822002644978.png)

### 9.9.4 explain 执行计划

EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。

语法：

```mysql
# 直接在 SELECT 语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```

演示如下：

![image-20220822003944683](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822003944683.png)

explain 执行计划各字段含义：

- id：select 查询的序列号，表示查询中执行 select 字句或者是操作表的顺序（<font color="red">id 相同，执行顺序从上到下；id不同，值越大，越先执行</font>)

- select_type：表示 select 的类型，常见的取值有 SIMPLE （简单表，即不使用表连接或子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT / WHERE 之后包含了子查询）等

- <font color="red">type</font>：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all

  > 当不查询表的时候，连接类型就是 NULL，实际开发过程中，优化成 NULL 几乎是不可能的；system 代表查询的是系统表；根据主键或唯一性索引访问其连接类型就为 const；使用非唯一性索引，其连接类型就是 ref

- possible_key：显示可能应用到这张表的索引，一个或多个

- <font color="red">key</font>：实际使用到的索引，如果为 NULL，则没有使用索引

- <font color="red">key_len</font>：表示索引使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好

- rows：MySQL 认为必须要执行查询的行数，在 InnoDB 引擎是是一个估计值，并非总是准确

- filtered：表示返回结果的行数占需要读取行数的百分比，filtered 的值越大越好

### 9.9.5 索引使用规则

#### 9.9.5.1 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引最左列开始，并且不跳过索引中的列

如果跳跃了某一列，<font color="red">索引将部分失效（后面的字段索引失效）</font>

演示：

首先我们创建一个联合索引：

```mysql
 create index idx_pro_age_sta on tb_user(profession,age,user_status);
```

![image-20220822111421297](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822111421297.png)

创建完成之后，我们查看索引，可以看到，按照顺序，最左边的索引应该是 profession ，往右分别是 age、user_status

①第一次查看执行计划

```mysql
explain select * from tb_user where profession='软件工程' and age=20 and user_status='2';
```

![image-20220822121143271](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822121143271.png)

> 使用了联合索引，此时索引的长度为 50

②第二次查看执行计划

```mysql
explain select * from tb_user where profession='软件工程' and age=20;
```

![image-20220822121438530](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822121438530.png)

> 使用了联合索引，此时索引长度为45，说明 status 关键字所占长度为5

③第三次查看执行计划

```mysql
explain select * from tb_user where profession='圆林艺术';
```

![image-20220822122600631](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822122600631.png)

> 我们可以看到这时仍然是走索引的，并且索引的长度为43，说明age关键字占用的长度为2
>
> 但这里需要注意的测试的用例中由于大部分数据都是"软件工程",所以如果我们查询的是"软件工程"，那么 mysql 会认为执行全表扫描更快

④第四次查看执行计划

```mysql
explain select * from tb_user where age=20 and user_status='2';
```

![image-20220822125720581](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822125720581.png)

> 由于没有满足最左前缀法则，索引失效

⑤第五次查看执行计划

```mysql
explain select * from tb_user where profession='圆林艺术' and user_status='7';
```

![image-20220822130008782](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822130008782.png)

> 我们可以看到 key 的长度和只有 profession 时的长度相同，说明出现了部分失效，即后面的 user_status 索引部分失效

⑥第六次查看执行计划

```mysql
explain select * from tb_user where age=20 and user_status='2' and profession='软件工程';
```

![image-20220822130303675](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822130303675.png)

> 打乱顺序后，我们发现联合索引依然可以使用，且 key 的长度为 50，说明没有存在部分失效的情况，也就是说只要最左侧列只要存在就可以走索引，与顺序无关

范围查询：

<font color="red">联合索引中，出现范围查询（>,<）,范围查询右侧的列索引可能会失效</font>，如果需要规避，我们可以使用(>= 或 <=)

⑦第七次查看执行计划

![image-20220822131456285](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822131456285.png)



#### 9.9.5.2 索引失效的情况

##### 失效情况一：索引列运算

<font color="red">不要在索引列上进行运算操作，否则索引将失效</font>

演示如下：

我们首先给 phone 建立索引

```mysql
create index pho on tb_user(phone);
```

首先查询第一条执行计划

```mysql
mysql> explain select * from tb_user where phone='1779999001';
```

![image-20220822133137214](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822133137214.png)

再来查询第二条执行计划

```mysql
explain select * from tb_user where substring(phone,10,2)='01';
```

![image-20220822133211466](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822133211466.png)



通过上述对比，我们发现：<font color="red">当我们在索引列上进行运算操作时，索引失效</font>

##### 失效情况二：不给字符串类型数值添加引号

<font color="red">字符串类型字段使用时，不加引号，索引将失效</font>

```mysql
explain select * from tb_user where phone=1779999001;
```

![image-20220822133558737](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822133558737.png)

##### 失效情况三：模糊匹配数据头部

<font color='red'>如果仅仅是尾部模糊匹配，索引不会失效。但如果是头部模糊匹配，索引将要失效</font>

```mysql
explain select * from tb_user where profession like '圆林%';
```

![image-20220822135229833](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822135229833.png)

```mysql
explain select * from tb_user where profession like '%工程';
```

![image-20220822135245619](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822135245619.png)

##### 失效情况四：or 的使用条件

<font color="red">用 or 分隔分割开的条件，如果 or 前面有列索引，而后面的列没有索引，那么涉及的索引都不会被用到</font>

```mysql
explain select * from tb_user where id=1 or age =20;
```

![image-20220822152102624](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822152102624.png)

由于 age 没有索引，所以即使 id 有索引，索引也会失效，所以需要针对 age 也建立索引

```mysql
-- 建立索引
create index id_age on tb_user(age);

-- 再次查看执行计划
explain select * from tb_user where id=1 or age =20;
```

![image-20220822152417974](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822152417974.png)

##### 失效情况五：数据分布影响

<font color="red">如果 MySQL 评估使用索引比全表更慢，则不使用索引</font>

```mysq
explain select * from tb_user where phone >= '17799990000';
```

![image-20220822160307697](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822160307697.png)

```mysql
explain select * from tb_user where phone >= '17799990080';
```

![image-20220822161054398](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822161054398.png)

```mysql
 explain select * from tb_user where profession is null;
```

![image-20220822160747592](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822160747592.png)

```mysql
 explain select * from tb_user where profession is not null;
```

![image-20220822160813597](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822160813597.png)

从上面看出数据分布情况也会决定 mysql 走不走索引

### 9.9.6 SQL 提示

SQL 提示是优化数据库的一个重要手段，简单来说，就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。

- use index：推荐使用索引
- igore index：忽略索引
- force index：强制使用索引

演示如下：

```mysql
# 之前我们已经给 profession、age、user_status 一个联合索引，此时我们再给 profession 来一个单列索引
create index user_pro on tb_user(profession);

# 接下来我们来查看下面的查询 profession 的语句会使用那一个索引
explain select * from tb_user where profession='园林艺术';
```

显示结果如下：

![image-20220822163211058](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822163211058.png)

```mysql
# 由上图可以看出 mysql 选择了 联合索引，我们使用 use index
explain select * from tb_user use index(user_pro) where profession='园林艺术';
```

![image-20220822163512216](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822163512216.png)

此时 mysql 就接纳了 user_pro 这个索引，其他的忽略索引和强制索引也很好理解，就是需要注意放在 from table_name 后面即可

### 9.9.7 覆盖索引

尽量使用覆盖索引（查询使用了覆盖索引，并且返回需要返回的列，在该索引中已经全部能够找到），减少 `select *`

![image-20220822171244575](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822171244575.png)

我们重点观察一下第二条 SQL 语句，会发现由于第二条语句走的是辅助索引（也称为"二级索引"），此时查询的叶子节点会存储有主键 id 的值，而查询的返回值恰好就是需要 id 和 name ,此时我们就不需要再进行回表查询，==所以当辅助索引将聚集索引覆盖的索引就称为覆盖索引==

![image-20220822171918550](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822171918550.png)

回表查询如上图。

所以我们之所以要避免使用 `select *`，就是因为容易产生回表查询，除非建立一个全局索引，设置一个联合索引，包括==表中除主键外的所有字段==，否则效率极低



**思考题**：如果我们现在有一张表tb_user，表中有四个字段（id，user_name，user_password，status)，由于数据量大，需要对以下 SQL 语句进行优化，该如何进行优化？

```mysql
select id,user_name,user_password from tb_user where user_name='itcast';
```

**答案**：给 user_name 和 user_password 建立一个联合索引即可，如此，我们只需要在辅助索引中就可以找到 id ，不需要进行回表查询，查询效率高



### 9.9.8 前缀索引

当字段类型为字符串（varchar、text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 ID ，影响查询效率。此时可以==只将字符串的一部分前缀，建立索引==，这样可以大大节约索引空间，从而提高索引效率。

语法如下：

```mysql
create index idx_xxxx on table_name(column(n));
```

> n 决定前缀长度，而前缀长度可以根据索引的选性来决定，而选择性是指不重复的索引值（基数）和数据表中的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的

采取测试语句：

```mysql
select count(distinct sUbstring(字段名,start,len)/count(*)) from table_name;
```

演示如下：

```mysql
# 我们以之前的 tb_user 中的 phone 为例
select count(distinct substring(phone,1,11))/count(*) from tb_user;
# 选择性结果为1，继续缩短前缀
select count(distinct substring(phone,1,10))/count(*) from tb_user;
# 选择性结果为1，继续缩短前缀
select count(distinct substring(phone,1,9))/count(*) from tb_user;
# 选择性降为了0.200，性能较差，我们选择前缀10 建立索引
create index idx_pho_10 on tb_user(phone(10));
```

**前缀索引的流程**

![image-20220822181008970](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822181008970.png)

我们有时并不需要选择性达到1也同样可以保证数据传出的正确性，原因就在于<font color="red">前缀索引的执行流程</font>：首先从数据表中截取字段，与 B+树上存储的字段进行比较，之后返回到聚集索引找到行数据，将返回数据与where 后面完整的条数查询的数据进行比对，确认无误后打印出来

### 9.9.9 单列索引和联合索引

- 单列索引：即一个索引只包含单个列
- 联合索引：即一个索引包含了多个列

在业务场景中，如果存在多个查询条件，考虑对于查询字段建立索引时，建议建立联合索引，而非单列索引。<font color="red">在多条件查询时，MySQL优化器会评估那个字段的索引效率更高，会选择该索引完成本次查询</font>

**联合索引的执行流程**

![image-20220822191211502](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822191211502.png)

建立 B+ Tree ，首先根据  phone 进行排序，phone相同再来根据 name 进行排序

### 9.9.10 索引设计原则

1. 针对数据量较大，且查询比较频繁的表建立索引

2. 针对与常作为查询条件（where)、排序（order by)、分组（group by）操作的字段建立索引
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用的索引效率越高
4. 如果是字符串类型的字段，字符的长度比较长，可以针对字段的特点，建立前缀索引
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率
7. 如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 来约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定是那个索引最有效地用于查询



# 10 SQL 优化

## 10.1 插入数据

**数据量不大时的插入数据优化（一般为 500 ~ 1000条）**

1. 批量插入

   ```mysql
   insert into tb_test values(1,'Tom'),(2,'cat');
   ```

2. 手动事务提交

   ```mysql
   start transaction;
   insert语句
   …
   commit;
   -- 减少事务的开启与提交
   ```

3. 主键顺序插入

   ```
   主键乱序插入: 2 8 7 6 5 1 4 3
   主键顺序插入: 1 2 3 4 5 6 7 8
   ```

**大批量插入数据**

如果一次性需要插入大批量数据，使用 insert 语句插入性能较低，此时可以使用 `load`指令进行插入。操作如下：

![image-20220822204831569](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822204831569.png)

```mysql
# 客户端连接服务端时，加上参数 --local-infile
mysql --local-infile -u root -p
# 设置全局参数 local_infile 为 1，开启从本地加载导入数据的开关
set global local_infile=1;
# 执行 load 指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1/log'into table `tb_user` fields terminated by ',' lines terminated by '\n';
```

演示如下：

准备工作：

```mysql
# 1.客户端连接上服务器
mysql --local-infile -u root -p
```

![image-20220822211518819](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822211518819.png)

```mysql
# 2.创建一个新数据库
create database itheima;
use itheima;
```

```mysql
# 3. 查看从本地加载的参数 local_infile 是否打开
select local_infile;
# 如果为0表示未打开，我们需要打开
set global local_infile=1;

# 4. 创建表
CREATE TABLE `tb_user` (
  `id` INT(11) NOT NULL AUTO_INCREMENT,
  `username` VARCHAR(50) NOT NULL,
  `password` VARCHAR(50) NOT NULL,
  `name` VARCHAR(20) NOT NULL,
  `birthday` DATE DEFAULT NULL,
  `sex` CHAR(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `unique_user_username` (`username`)
) ENGINE=INNODB DEFAULT CHARSET=utf8 ;
```

[点击此处](https://gitee.com/Jiuling01/my_note.git)下载准备好上传的演示文件

![image-20220822215444116](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822215444116.png)

![image-20220822215602683](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822215602683.png)

5.通过 `pwd`指令获取当前路径

![image-20220822220015752](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822220015752.png)

```mysql
# 6. 上传文件
load data local infile '/home/ranpis01/load_user_100w_sort.sql' into table tb_user fields terminated by ',' lines terminated by '\n';
```

查看上传结果：

![image-20220822220543639](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822220543639.png)

可以看到此时 100w 的数据已经成功加载进来

## 10.2 主键优化

**数据组织方式**

在 Inno 存储引擎中，表数据都是根据主键顺序组织存放的，这种存放方式的表称为<font color="red">索引组织表</font>（index organized table <font color='red'>IOT</font>)

**页分裂**

页可以为空，也可以填充一半，也可以填充 100%。每个页包含了2-N行数据（如果一行数据很大，会行溢出）。根据主键排列

**页合并**

当删除一行记录式，实际上记录并没有被物理删除，只是记录被标记为删除并且它的空间变得允许被其他声明使用。当野种删除的记录达到 MERGE_THRESHOLD (默认为页的 50%)，InnoDB 会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用

**主键设计原则**

- 满足业务需求的情况下，尽量降低主键的长度
- 插入数据时，尽量选择顺序插入，选择 AUTO_INCREMENT 自增主键
- 尽量不要使用 UUID（==不重复的随机字符串== ，这里推荐去了解什么是==雪花 ID==） 做主键或者是其他自然主键，如身份证号
- 业务操作时，避免对主键的修改

## 10.3 order by 优化

1. Using filesort：通过表的索引或全表扫描，读满足条件的数据行，然后再缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫做 FileSort 排序
2. Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高

演示如下：

```mysql
# 准备好数据,在itcast数据库中中执行以下命令
create table tb_user2(
	id int primary key auto_increment comment '主键',
	name varchar(50) not null comment '用户名',
	phone varchar(11) not null comment '手机号',
	email varchar(100) comment '邮箱',
	profession varchar(11) comment '专业',
	age tinyint unsigned comment '年龄',
	gender char(1) comment '性别 , 1: 男, 2: 女',
	status char(1) comment '状态',
	createtime datetime comment '创建时间'
) comment '系统用户表';


INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('曹操', '17799990001', 'caocao666@qq.com', '通讯工程', 33, '1', '0', '2001-03-05 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('赵云', '17799990002', '17799990@139.com', '英语', 34, '1', '2', '2002-03-02 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('花木兰', '17799990004', '19980729@sina.com', '软件工程', 23, '2', '1', '2001-04-22 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('吕布', '17799990000', 'lvbu666@163.com', '软件工程', 23, '1', '6', '2001-02-02 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('大乔', '17799990005', 'daqiao666@sina.com', '舞蹈', 22, '2', '0', '2001-02-07 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('露娜', '17799990006', 'luna_love@sina.com', '应用数学', 24, '2', '0', '2001-02-08 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('孙悟空', '17799990003', '17799990@sina.com', '工程造价', 54, '1', '0', '2001-07-02 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('程咬金', '17799990007', 'chengyaojin@163.com', '化工', 38, '1', '5', '2001-05-23 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('项羽', '17799990008', 'xiaoyu666@qq.com', '金属材料', 43, '1', '0', '2001-09-18 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('白起', '17799990009', 'baiqi666@sina.com', '机械工程及其自动化', 27, '1', '2', '2001-08-16 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('韩信', '17799990010', 'hanxin520@163.com', '无机非金属材料工程', 27, '1', '0', '2001-06-12 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('荆轲', '17799990011', 'jingke123@163.com', '会计', 29, '1', '0', '2001-05-11 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('兰陵王', '17799990012', 'lanlinwang666@126.com', '工程造价', 44, '1', '1', '2001-04-09 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('狂铁', '17799990013', 'kuangtie@sina.com', '应用数学', 43, '1', '2', '2001-04-10 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('貂蝉', '17799990014', '84958948374@qq.com', '软件工程', 40, '2', '3', '2001-02-12 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('妲己', '17799990015', '2783238293@qq.com', '软件工程', 31, '2', '0', '2001-01-30 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('芈月', '17799990016', 'xiaomin2001@sina.com', '工业经济', 35, '2', '0', '2000-05-03 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('嬴政', '17799990017', '8839434342@qq.com', '化工', 38, '1', '1', '2001-08-08 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('狄仁杰', '17799990018', 'jujiamlm8166@163.com', '国际贸易', 30, '1', '0', '2007-03-12 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('安琪拉', '17799990019', 'jdodm1h@126.com', '城市规划', 51, '2', '0', '2001-08-15 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('典韦', '17799990020', 'ycaunanjian@163.com', '城市规划', 52, '1', '2', '2000-04-12 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('廉颇', '17799990021', 'lianpo321@126.com', '土木工程', 19, '1', '3', '2002-07-18 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('后羿', '17799990022', 'altycj2000@139.com', '城市园林', 20, '1', '0', '2002-03-10 00:00:00');
INSERT INTO itcast.tb_user2 (name, phone, email, profession, age, gender, status, createtime) VALUES ('姜子牙', '17799990023', '37483844@qq.com', '工程造价', 29, '1', '4', '2003-05-26 00:00:00');
```

```mysql
# 1.我们查看索引，可以看到刚开始里面只有一个主键索引
show index from tb_user2;
```

```mysql
# 2. 测试1：
explain select id,age,phone from tb_user2 order by age,phone;
```

![image-20220822235423403](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822235423403.png)

可以看到，由此没有给 age和phone 创建联合索引，所以排序采用的是全表扫描，效率较低

```mysql
# 3. 测试2：先给 age 和 phone 创建索引在查看执行计划
create index idx_age_pho_seq on tb_user2(age,phone);
explain select id,age,phone from tb_user2 order by age,phone;
```

![image-20220822235758228](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220822235758228.png)

此时就成了索引扫描，效率高

```mysql
# 4. 测试3：要求 age 和 phone 都要倒序排序
explain select id,age,phone from tb_user2 order by age desc,phone desc;
```

![image-20220823000015265](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823000015265.png)

可以看到此时仍然是索引扫描，只不过成了反向扫描索引

```mysql
# 5. 测试4：将 age 和 phone 顺序颠倒
explain select id,age,phone from tb_user2 order by phone, age;
```

![image-20220823000959073](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823000959073.png)

由于 phone 和 age 的顺序与默认的索引排序顺序颠倒，导致出现了 using filesort

```mysql
# 6. 测试5：要求 age 倒序 和 phone 升序
explain select id,age,phone from tb_user2 order by age desc, phone asc;
```

![image-20220823001029281](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823001029281.png)

结果还是出现了 using filesort，原因类似测试4，解决方案

```mysql
# 7. 解决测试5出现的全文扫描
create index idx_age_r_pho_s on tb_user2(age desc,phone asc);
```

查看创建的索引：

```mysql
show index from tb_user2;
```

![image-20220823001504972](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823001504972.png)

我们会发现创建的索引此时 age 的排序方式为 D（desc)，而 phone 的排序方式为 A （asc)

```mysql
# 查看执行计划
explain select id,age,phone from tb_user2 order by age desc, phone asc;
```

![image-20220823001656529](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823001656529.png)

这下问题解决。

**总结**

- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
- 尽量使用覆盖索引
- 多字段排序，一个升序一个降序，此时要注意联合索引在创建时的规则
- 如果不可避免地出现 filesort ，大量数据排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)

```mysql
# 查看变量
show variables like 'sort_buffer_size';
# 修改变量 
set sort_buffer_size = xxx;
```



## 10.4 group by 优化 

我们在使用 group by 进行分组查询时，需要注意最左前缀法则

group by 或 where 后面必须要接索引的第一个字段

```mysql
create index idx_pro_age_sta on tb_user2(profession,age,status);

explain select profession ,count(*) from tb_user group by profession;

explain select profession ,count(*) from tb_user group by profession;

explain select age ,count(*) from tb_user where profession = '软件工程' group by profession;
```



## 10.5 limit  优化

```mysql
# 查看第一页的10个记录
limit 0,10;
# 查看第二页的10个记录
limit 10,10;
…
# 查看第80001页的10个记录
limit 800000,10;
# 此时我们会发现执行效率特别低
```

> 上述为简写代码

使用 limit 分页查询的时候，当起始位置变大，那么执行效率也会变得越来越低，为了优化 limit ，MySQL 官方给出的方案为 覆盖索引 + 子查询 的方式

```mysql
select * from tb_user order by id limit 900000,10; # 效率低
```

```mysql
select * from tb_user where id in (select id from tb_user order by id limit 900000,10) # 语法不支持
```

```mysql
select * from tb_user a,(select id from tb_user order by id limit 900000,10) b where a.id = b.id; # 支持且效率高
```

![image-20220823010959382](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823010959382.png)

![image-20220823011013915](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823011013915.png)



## 10.6 count 优化

```mysql
explain select count(*) from tb_user;
```

我们在使用 count进行查询的时候，发现无论数据量有多大，查询 count 的效率总是很高的，原因在于：

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count 的这个操作的时候会直接返回这个数，效率很高(前提是后面没有where查询)
- InnoDB 引擎就比较麻烦，它在执行 count 的操作时，需要把数据一行一行地从引擎中读取出来，然后累计计数

<font color="green">优化思路：自己计数</font>

**count 的几种用法**

- count(*)、count(主键)、count(字段)、count(1)

> `count(null)`就是0 ，而`count(1)`代表的是先将查询的每一条返回记录都会放1，然后再在服务层计数

- count（主键）
  InnoDB引擎会遍历整张表，==把每一行的主键id值都取出来==，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为null）。
- count（字段）
  没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。
- count (1)
  InnoDB引擎遍历整张表，但==不取值==。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。
- count(*)
  InnoDB引擎并不会把全部字段取出来，而是专门做了优化，==不取值==，服务层直接按行进行累加。

按照效率排序的话：$ connt(字段) \lt count(主键) \lt count(1) \approx count(*) $，所以尽量使用 `count(*)`

## 10.7 update优化

<font color="red">InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁加的锁，并且该索引不能失效，否则会从行级锁升级为表锁</font>

演示：

我们首先同时打开两个窗口，都进入到 itcast 数据库中，我们之前在 itcast数据库创建了表 tb_user2:

![image-20220823113655808](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823113655808.png)

接下来我们设置事务为手动提交

```mysql
set @@autocommit=0;
```

两个窗口同时开启事务

```mysql
begin;
```

两个窗口分别进行更新操作

```mysql
#  窗口1
update tb_user2 set name='test1' where id=1;
# 窗口2
update tb_user2 set name='test2' where id=2;
```

由于 InnoDB 引擎是对索引建立的行级锁，而 id 设置了主键索引，所以这两个事务可以互不影响

我们直接重新开启事务：

```mysql
# 窗口1
update tb_user2 set name='test1' where name='曹操';
# 窗口2
update tb_user2 set name='test2' where name='赵云';
```

这时我们发现对非索引记录设置的是表锁，除非事务1提交，否则事务2不能继续执行

![image-20220823114627441](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823114627441.png)

```mysql
# 下面的语句也是一样的道理，事务会将表锁住
# 窗口1
update tb_user2 set name='test1' where name='曹操';
# 窗口2
update tb_user2 set name='test2' where id=2;
```

# 11 视图 / 存储过程 / 触发器

## 11.1 视图

### 11.1.1 介绍

视图（View）是一种==虚拟==存在的表。<font color="red">视图中的数据并不在数据库中实际存在</font>，行和列数据来自定义视图的查询中使用的表，并且在使用视图时动态生成。

通俗的讲，视图只保存了查询的 SQL 逻辑，不保存查询结果。所以我们在创建视图的时候，主要工作就落在创建这条 SQL 语句上。

```mysql
# 创建
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]
```

```mysql
# 查询
# 查看创建视图语句
SHOW CREATE VIEW 视图名称
# 查看视图数据
SLEECT * FROM 视图名称
```

```MYSQL
# 修改
# 方式一
CREATE [or replace] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]

# 方式二
ALTER VIEW 视图名称[(名称列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION]
```

```mysql
# 删除
DROP VIEW [IF EXISTS] 视图名称[,视图名称]…
```

演示代码：

```mysql
use itcast;
show tables;
-- 创建视图
create or replace view view_user as select * from tb_user where id < 10;

-- 查看视图创建语句
show create view view_user;

-- 查看视图数据
select * from view_user;

-- 修改视图
create or replace view view_user as select id,user_name,phone from tb_user where id < 10;

-- 修改视图2
alter view view_user as select * from tb_user where id < 10;

-- 删除视图
drop view if exists view_user;
```



### 11.1.2 检查选项

演示如下：

```mysql
-- 创建新视图
create or replace view view_user as select id,user_name from tb_user where id < 5;
-- 插入数据
insert into view_user(id,user_name) values(11,'Tom');
-- 查询数据
select * from view_user;
```

我们知道视图时不存储数据的，插入到视图的数据最终都会插入到其基表里面

![image-20220823151337756](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823151337756.png)

但我们<font color="red">插入在视图里面但结果却无法通过视图查询</font>，而了避免这种情况，我们可以使用`with cascaded check option`来避免这种情况的发生

```mysql
-- 修改原视图
create or replace view view_user as select id,user_name from tb_user where id < 5 with cascaded check option;
```

这时候再来插入就发现提示错误：

![image-20220823152117303](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823152117303.png)



#### 视图的检查选项

当使用 WITH CHECK OPTION 子句创建视图时，MySQL 会通过视图检查正在更改的每一个行，例如插入，更新，删除，以使其符合视图的定义。MySQL 允许给予另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，MySQL 提供了两个选项：CASCADE 和 LOCAL ，默认为 CASCADE

#### cascade

![image-20220823160556062](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823160556062.png)

```mysql
create or replace view v1 as select id,user_name from tb_user where id < 5;
create or replace view v2 as select id,user_name from v1 where id < 10 with cascaded check option;

insert into v1 values(4,'Tom'); # 执行成功
insert into v1 values(6,'Tom'); # 执行成功
-- 删除上面新插入的数据
insert into v2 values(4,'Tom'); # 执行成功
insert into v2 values(6,'Tom'); # 执行失败
```

cascaded 本义就是级联的意思，当我们给一个视图添加`with cascaded check option `，我们在对该视图修改数据的时候，不仅会检查更改的行是否满足当前视图的要求，还会检查是否满足它所依赖的视图的要求。



#### local

```mysql
-- 创建新视图
create or replace view v4 as select id,user_name from tb_user where id < 10;
create or replace view v5 as select id,user_name from v4 where id < 15 with local check option;

-- 测试数据
insert into v5 values(11,'Tom');    # 执行成功
insert into v5 values(17,'Tom');    # 执行失败
-- 更改视图
create or replace view v4 as select id,user_name from tb_user where id < 10 with local check option;
-- 再次测试
insert into v5 values(11,'Tom');    # 执行失败
```

local 选项的含义是：如果使用了 `with local check option`后，那么该视图所依赖的视图如果没有添加`with check option`约束则不检查修改的数据是否满足这个依赖的视图的条件，而如果有这个约束则需要检查

### 11.1.3 视图更新的条件和作用

#### 条件

要使视图可更新，==视图中的行与基础表中的行之间必须存在一对一的关系==。如果视图包含以下任何一项，则该视图不可更新：

1. 聚合函数或窗口函数（SUM()、MIN()、MAX()、COUNT() 等）
2. DISTINCT
3. GROUP BY
4. HAVING 
5. UNION 或者 UNION ALL

#### 作用

1. 简单

   视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部条件

2. 安全

   数据库可以授权，但不能授权到数据特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据

3. 数据独立

   视图可以帮助用户屏蔽真实表结构变化带来的影响

### 11.1.4 案例（P101）



## 11.2 存储过程

### 11.2.1 存储过程介绍

存储过程时事先经过编译并存储在数据库中的==一段 SQL 语句的集合==，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是由好处。

<font color="red">存储过程其实就是数据库 SQL 语言层面的代码封装和重用</font>

![存储过程](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.jpg)

存储过程的特点：

- 封装，复用
- 可以接收参数，也可以返回数据
- 减少网络交互，提升效率



### 11.2.2 基本语法

```mysql
-- 创建
CREATE PROCEDURE 存储过程名称([参数列表])
BEGIN
	-- SQL 语句
END;

-- 调用
CALL 名称([参数]);

-- 查看
# 查看指定数据库的存储过程及状态信息
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'XXX';
# 查看某个存储过程的定义
SHOW CREATE PROCEDURE 存储名称;

-- 删除
DROP PROCEDURE [IF EXISTS] 存储名称
```

演示如下：

```mysql
use itcast;
-- 创建存储过程
create procedure p1()
begin
    select * from tb_user;
end;

-- 调用
call p1();

-- 查看
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'itcast';

show create procedure p1;

-- 删除
drop procedure if exists p1;
```

---

<font color="red">问题：我们在命令行中创建存储过程由于存在结束符`;`会出问题</font>

解决方法：通过关键字`delimiter` 指定 SQL 语句的结束符。

实现代码：

```mysql
delimiter $$
create procedure p1()
begin
    select * from tb_user;
end$$
```

![image-20220823180306215](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220823180306215.png)

### 11.2.3 变量

#### 系统变量

<font color="red">系统变量</font> 是MySQL 服务器提供，不是用户定义的，属于服务器层面。分为全局变量(<font color='red'>GLOBAL</font>)、会话变量(<font color="red">SESSION</font>)

```mysql
-- 查看系统变量
# 查看所有的系统变量
SHOW [SESSION | GLOBAL] VARIABLES;
# 通过模糊匹配方式查找变量
SHOW [SESSION | GLOBAL] VARIABLES LIKE '…';
# 查看指定变量的值
SELECT @@[SESSION | GLOBAL].系统变量名;

-- 设置系统变量
SET [SESSION | GLOBAL] 系统变量名=值;
SET @@[SESSION | GLOBAL].系统变量名=值;
```

注意：

- 如果没有指定 SESSION / GLOBAL ,默认是SESSION，会话变量
- MySQL 服务器重新启动后，所设置的全局参数会失效，要想不失效，可以在 /etc/my.cnf 中配置

#### 用户自定义变量

<font color="red">用户自定义变量</font> 是用户根据需要自己定义的变量，用户变量不用提前声明，在使用的时候直接用 `@变量名` 使用即可。其作用域为当前连接。

```MYSQL
-- 赋值
SET @var_name = expr[,@var_name=expr]…;
SET @var_name := expr[,@var_name:=expr]…;
```

```mysql
SELECT @var_name := expr[,var_name := expr]…;
SELECT 字段名 INTO @var_name FROM 表名;
```

```mysql
-- 使用
SELECT @var_name;
```

演示如下：

```mysql
-- 赋值
set @my_name := 'itcast',@myage := 18;
select @mycolor := 'red';
select count(*) into @mycount from tb_user;

-- 使用
select @my_name;
```

注意：

- MySQL 中等号`=`即可用于赋值运算，也可以用于比较运算，MySQL 中没有`==`这种形式，所以建议在赋值的时候最好使用`:=`
- 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为 NULL

```mysql
-- 查询一个未声明的变量
select @abc;	# 执行结果为 NULL
```

#### 局部变量

<font color="red">局部变量</font> 是根据需要定义的在局部生效的变量，访问之前，需要 DECLARE 声明。可用做存储过程内的局部变量和输入参数，局部变量的范围是在其声明的 BEGIN…END 块中

```mysql
-- 声明
DECLARE 变量名 变量类型 [DEFAULT …];
```

变量类型就是数据库字段类型：INT 、BIGINT、CHAR、VARCHAR、DATE、TIME等

```mysql
-- 赋值
SET 变量名 = 值;
SET 变量名 := 值;
SELECT 字段名 INTO 变量名 FROM 表名…;
```

演示如下：

```mysql
create procedure p2()
begin
    declare user_count int default 0;
    select count(*) into user_count from tb_user;
    select user_count;
end;

call p2();
```



### 11.2.4 if 条件判断

```mysql
IF 条件1 THEN
	…
ELSE 条件2 THEN 	# 可选
	…
ELSE 			# 可选
	…
END IF;
```



**练习**：根据定义的分数 score 变量，判定当前分数对应的分数等级

1. score >= 85 ，等级为优秀
2. score >= 60 且 score < 85 ，等级为及格
3. score < 60，等级为不及格

```mysql
create procedure judge()
begin
    declare score int default 58;
    declare result varchar(10);

    if score >= 85 then
        set result := '优秀';
    elseif score >= 60 then
        set result := '及格';
    else
        set result := '不及格';
    end if;
    select result;
end;

call judge();
```

### 11.2.5 参数

参数类型

| 类型  | 含义                                         | 备注 |
| ----- | -------------------------------------------- | ---- |
| IN    | 该类参数作为输入，也就是需要调用时传入值     | 默认 |
| OUT   | 该类猜数作为输出，也就是该参数可以作为返回值 |      |
| INOUT | 既可以作为输入参数，也可以作为输出参数       |      |

语法

```mysql
CREATE PROCEDURE 存储过程名称([ IN/OUT/INOUT 参数名 参数类型])
BEGIN
	-- SQL 语句
END;

-- 调用
CALL 名称([参数]);
```

**练习**：

1.根据<font color="red">传入参数</font> score 变量，判定当前分数对应的分数等级

1. score >= 85 ，等级为优秀
2. score >= 60 且 score < 85 ，等级为及格
3. score < 60，等级为不及格

2.将<font color="red">传入</font>的200分制的分数，换算成百分制，然后<font color="red">返回</font>

```mysql
-- 题目一
create procedure judge(in score int,out result varchar(10))
begin
    if score >= 85 then
        set result := '优秀';
    elseif score >= 60 then
        set result := '及格';
    else
        set result := '不及格';
    end if;
    select result;
end;

call judge( 78, @result);
select @result;

-- 题目二
create procedure transform(inout score int)
begin
    set score := score*0.5;
end;
set @score=160;
call transform(@score);
select @score;
```



### 11.2.6 case

```mysql
-- 语法一
CASE case_value
	WHEN when_value1 THEN statement_list1
	[WHEN when_value2 THEN statement_list2]
	[ELSE statement_list]
END CASE;

-- 语法二
CASE 
	WHEN condition1 THEN statement_list1
	[WHEN condition2 THEN statement_list2]
	[ELSE statement_list]
END CASE;
```

**练习**：根据传入的月份，判定月份所属季度（要求采用 case 语句）

- 1-3 月份为第一季度
- 4-6 月份为第二季度
- 7-9 月份为第三季度
- 10-12 月份为第四季度

```mysql
create procedure judge_season(in month int)
begin
    declare result varchar(10);
    case
        when month >= 1 and month <= 3 then
            set result := '第一季度';
        when month >= 4 and month <= 6 then
            set result := '第二季度';
        when month >= 7 and month <= 9 then
            set result := '第三季度';
        else
            set result := '第四季度';
        end case;
    select concat('您输入的月份为：',month,'所属季度为：',result);
end;

call judge_season(12);
```



### 11.2.7 while

while 循环是有条件的循环控制语句。满足条件后，在执行循环体中的 SQL 语句，具体语法为：

```mysql
WHILE 条件 DO
		SQL逻辑
END WHILE;
```

**练习**：计算从 1 累加到 n 的值， n 为传入的参数值

```mysql
create procedure accumulate(in n int)
begin
    declare total int default 0;
    while n>0 do
        set total = total + n;
        set n = n - 1;
    end while;
    select concat('1+…+n的结果为：', total);
end;

call accumulate(100);
```

### 11.2.8 repeat 

repeat 是有条件的循环控制语句，当满足条件的时候退出循环。具体语法为：

```mysql
# 先执行一次逻辑，然后判断逻辑是否满足，如果满足，则退出；如果不满足，则进入下一次循环
REPEAT 
	SQL 逻辑
	UNTIL 条件
END REPEAT;
```

### 11.2.9 loop

loop 实现简单的循环，如果不在 SQL 逻辑中增加退出逻辑的条件，可以用其来实现简单的死循环。loop 可以配合以下两个语句使用“

- LEAVE：配合循环使用，退出循环
- ITERATE：必须用在循环中，作用是跳出当前循环剩下的语句，直接进入下一次循环

```mysql
[begin_label:]LOOP
	SQL 逻辑
END LOOP [end_label];
```

```
LEAVEL label;	-- 退出指定标记的循环体
ITERATE label;	-- 直接进入下一循环
```



### 11.2.10 游标 cursor

<font color="red">游标(CURSOR)</font> 是用来存储查询结果集的数据类型，在存储过程中和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法如下：

```mysql
-- 声明游标
DECLARE 游标名称 CURSOR FOR 查询语句;

-- 打开游标
OPEN 游标名称;

-- 获取游标记录
FETCH 游标名称 INTO 变量[,变量];

-- 关闭游标
CLOSE 游标;
```

<font color="red">条件处理程序（Handler）</font> 可以用来定义在流程控制执行结构中遇到问题时相应的处理步骤。具体语法为：

```mysql
DECLARE handler_action HANDLER FOR condition_value [,condition_value] … statement;

handler_action
	CONTINUE: 继续执行当前程序
	EXIT: 终止执行当前程序
condition_value
	SQLSTATE sqlstate_value: 状态码，如02000
	SQLWARNING: 所有以01开头的 SQLSTATE 代码的简写
	NOT FOUND: 所有以02开头的 SQLSTATE 代码的简写
	SQLEXCEPTION: 所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的简写
```

更多 SQLSTATE 详情参考 [MySQL 中文官方文档](https://www.docs4dev.com/docs/zh/mysql/5.7/reference/)

**练习**：根据传入的参数 uage，来查询用户表 tb_user 中，所有用户年龄小于等于 uage 的用户姓名（name）和专业（profession），并将用户的姓名专业插入到所创建的一张新表（id，name，profession）中

```mysql
use itcast;
-- 游标
create procedure p12(in uage int)
begin
    declare u_name varchar(50);
    declare u_pro varchar(50);
    -- 变量或条件声明必须在游标和处理程序之前
    -- 声明游标
    declare u_cursor cursor for select user_name,profession from tb_user where age <= uage;
    -- 声明处理程序
    declare exit handler for SQLSTATE '02000' close u_cursor;
	-- 对于 SQLSTATE '02000'我们也可以用 'NOT FOUND'来替代
    drop table if exists tb_user_pro;
    create table if not exists tb_user_pro(
        id int primary key auto_increment,
        user_name varchar(50),
        profession varchar(50)
    ) comment '专业表';

    open u_cursor;
    while true do
        fetch u_cursor into u_name ,u_pro;
        insert into tb_user_pro values(null,u_name,u_pro);
    end while;
end;

call p12(40);
```

[状态码查询文档](https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html)

### 11.2.11 存储函数

存储函数时有返回值的存储过程，存储函数的参数只能是==IN 类型==。具体语法如下：

```mysql
CREATE FUNCTION   存储函数名称([参数列表])
RETURNS type [characteristic…]
BEGIN
	-- SQL 语句
	RETURN…;
END;

characteristic 说明:
 	DETERMINISTIC :相同的输入参数总是产生相同的结果
 	NO SQL: 不包含 SQL 语句
 	READS SQL DATA: 包含读取数据的语句，但不包含写入数据的语句
```

**练习**：计算从1累加到n的值， n 为传入的参数值

```mysql
use itcast;
create function fun1(n int)
returns int deterministic
begin
    declare total int default 0;

    while n>0 do
        set total := total + n;
        set n = n - 1;
    end while;
    return total;
end;

select fun1(100);
```



## 11.3 触发器

<font color="red">触发器</font> 是与表有关的数据库对象，指定 insert / update / delete 之前或之后，触发并执行触发器中定义的 SQL 语句集合。触发器的这种特性可以协助应用在数据库端==确保数据的完整性、日志记录、数据校验等操作==。

使用别名 OLD 和 NEW 来引发触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持==行级触发==，不支持语句级触发。

| 触发器类型      | NEW 和 OLD                                               |
| --------------- | -------------------------------------------------------- |
| INSERT 型触发器 | NEW 表示将要或者已经新增的数据                           |
| UPDATE 型触发器 | OLD 表示修改的之前的数据，NEW 表示将要或已经修改后的数据 |
| DELETE 型触发器 | OLD 表示将要或者已经删除的数据                           |



```mysql
-- 创建
CREATE TRIGGER trigger_name
BEFORE/AFTER INSERT/UPDATE/DELETE
ON tbl_name FOR EACH ROW 	-- 行级触发器
BRGIN 
	trigger_stmt;
END;

-- 查看
SHOW TRIGGERS;

-- 删除
DROP TRIGGER [schema_name.]trigger_name;	-- 如果没有指定 schema_name，默认当前数据库
```



**练习**：通过触发器记录 tb_user 表的数据变更日志，将变更日志插入到日志表 user_logs 中，包含增加 、修改、删除，表结构如下：

```mysql
create table user_logs(
  id int(11) not null auto_increment,
  operation varchar(20) not null comment '操作类型, insert/update/delete',
  operate_time datetime not null comment '操作时间',
  operate_id int(11) not null comment '操作的ID',
  operate_params varchar(500) comment '操作参数',
  primary key(`id`)
)engine=innodb default charset=utf8;
```

代码如下：

```mysql
-- 创建日志表
create table user_logs(
  id int(11) not null auto_increment,
  operation varchar(20) not null comment '操作类型, insert/update/delete',
  operate_time datetime not null comment '操作时间',
  operate_id int(11) not null comment '操作的ID',
  operate_params varchar(500) comment '操作参数',
  primary key(`id`)
)engine=innodb default charset=utf8;

-- 创建insert型触发器（针对 tb_user）
create trigger tb_user_insert_log
    after insert on tb_user for each row
begin
    insert into user_logs values(null,'insert',now(),new.id,concat('插入的数据内容为：','user_name:',new.user_name,',phone:',new.phone,',email:',new.email));
end;

-- 创建update型触发器
create trigger tb_user_update_log
    after update on tb_user for each row
begin
    insert into user_logs values(null,'update',now(),new.id,concat('更新之前的数据:','user_name=',old.user_name,',phone=',old.phone,',email=',old.email,
                                                                '| 更新之后的数据:','user_name=',new.user_name,',phone=',new.phone,',email=',new.email));
end;

-- 创建delete型触发器
create trigger tb_user_delete_log
    after delete on tb_user for each row
begin
    insert into user_logs values(null,'delete',now(),old.id,concat('删除的数据内容为：','user_name=',old.user_name,',phone=',old.phone,',email=',old.email));
end;
-- 创建
-- 测试数据
insert into tb_user(id,user_name,phone,email) values(null,'曹操','15350200806','666888@163.com');
```



## 11.4 锁

<font color="red">锁</font>是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算机资源(CPU、RAM、I/O)的竞争外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须要解决的一个问题，锁冲突也是影响数据库性能的一个重要因素。



### 11.4.1 全局锁

<font color="red">全局锁</font>就是对整个数据库实例加锁，加锁后整个实例就是处于==只读状态==，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。

例如：最典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性

![全局锁](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/%E5%85%A8%E5%B1%80%E9%94%81.jpg)

演示如下：

1.我们打开 windows 的命令行工具，同时创建两个窗口，都输入

```bash
mysql -h192.168.238.129 -uroot -p	# 这里的host主机地址要根据自己虚拟机来设置
```

之后输入密码，登录进去



2.切换数据库

```mysql
use itcast;
```



3.设置全局锁

```mysql
flush tables with read lock;
```

> 此时是无法再对 itcast 数据库中的数据进行操纵的



4.备份 itcast 数据库

```bash
mysqldump -h192.168.238.129 -uroot -p1234 itcast > D:/itcast.sql
# 注意这条语句不是 mysql 命令，而是 cmd 命令
```

最终备份结果：

![image-20220824175422217](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220824175422217.png)

> 这里提示我们将密码显示在命令行是不安全的，我们可以在D盘的 itcast.sql 里查看文件



5.关闭数据库

```mysql
unlock tables;
```



全局锁的特点：

数据库中加全局锁，是一个比较重的操作，存在以下问题：

1. 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
2. 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二级制日志( binlog)，会导致主从延迟



在 InnoDB 引擎中，我们可以在备份时加上参数 `--single-transaction`来完成不加锁的一致性数据备份,例如：

```bash
mysqldump --single-tranaction -uroot -p1234 itcast > itcast.sql
```



### 11.4.2 表级锁

<font color="red">表级锁</font>，每次操作锁住整张表，锁定==粒度==大，发生锁冲突的概率最高，并发度最低。应用在 MyISAM、InnoDB、DDB等存储引擎中。

对于表级锁，主要分为以下三类：

1. 表锁
2. 元数据锁（meta data lock,MDL)

3. 意向锁



#### 11.4.2.1 表锁

对于表锁，分为两类：

1. 表共享锁(read lock)
2. 表独占锁(write lock)

语法：

```mysql
-- 1.加锁
lock tables table_name1,table_name2,… read /write

-- 2.释放锁
unlock tables 
-- 或者我们将客户端断开连接也可以释放锁
```

![r](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220824183844563.png)

![image-20220824183800987](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220824183800987.png)



#### 11.4.2.2 元数据锁

MDL 加锁过程时系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁的主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对原数据进行写入操作。<font color="red">为了避免 DML 与 DDL 冲突，保证读写的正确性。</font>

在 MySQL5.5 中引入 MDL ，当对一张表进行增删查改的时候，加 MDL 读锁(共享)；当对表结构进行变更操作的时候，加 MDL 写锁（排他）。

| 对应SQL                                     | 锁类型                                  | 说明                                                   |
| ------------------------------------------- | --------------------------------------- | ------------------------------------------------------ |
| lock tables xxx read/write                  | SHARED_READ_ONLY / SHARED_NO_READ_WRITE |                                                        |
| select 、select … lock in share mode        | SHARED_READ                             | 与 SHARED_READ 、SHAREAD_WRITE 兼容，与 EXCLUSIVE 互斥 |
| insert、update、delete、select … for update | SHARED_WRITE                            | 与 SHARED_READ 、SHAREAD_WRITE 兼容，与 EXCLUSIVE 互斥 |
| alter table…                                | EXCLUSIVE                               | 与其他的 MDL 都互斥                                    |

查看元数据锁：

```mysql
select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;
```

> 我们在开启事务并且执行相应的 sql 语句之后再输入这条语句才能进行查看



#### 11.4.2.3 意向锁

为了避免 DML 在执行时，加的行锁与表锁冲突，在InnoDB 中引入意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的查询

1. 意向共享锁(IS)：与表锁共享锁（read）兼容，与表锁排他锁（write）互斥

2. 意向排他锁(IX)：与表锁共享锁（read）和表锁排他锁（write）都互斥。意向锁之间不会互斥


看以通过以下语句来查看意向锁及行锁的加锁情况：

```mysql
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```

### 11.4.3 行级锁

行级锁，每次操作锁住对应的行数据。锁定==粒度==最小，发生锁冲突概率最低，并发度最高。应用在 InnoDB 引擎中。

InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：

1. 行级锁(Record Lock): 锁定单个记录的锁，防止其他事务对此行进行 update 和 delete 。在 RR 和 RC 级别下都支持
2. 间隙锁(Gap Lock): 锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下都支持
3. 临键锁(Next-Key Lock): 行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙 Gap。在 RR 隔离级别下支持

![image-20220824203605420](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220824203605420.png)

> RR 指的是 "Repeatable Read"，RC 指的是 "Read Commit"



#### 11.4.3.1 行锁分类

InnoDB 实现了以下两种类型的行锁：

1. 共享锁(S): 允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁
2. 排它锁(X): 允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排它锁

|      | S    | X    |
| ---- | ---- | ---- |
| S    | 兼容 | 冲突 |
| X    | 冲突 | 冲突 |

| SQL                         | 行锁类型                        | 说明                          |
| --------------------------- | ------------------------------- | ----------------------------- |
| INSERT                      | 排它锁                          | 自动加锁                      |
| UPDATE                      | 排它锁                          | 自动加锁                      |
| DELETE                      | 排它锁                          | 自动加锁                      |
| SELECT                      | <font color="red">不加锁</font> | 自动加锁                      |
| SELECT … LOCK IN SHARE MODE | 共享锁                          | 需要手动加 LOCK IN SHARE MODE |
| SELECT…FOR UPDAT            | 排它锁                          | 需要手动加 FOR UPDATE         |





