文章写的太好，故此记录下来供自己查阅，原文章链接：https://blog.csdn.net/zhige_me/article/details/80980566

如果现在给你出下面这道面试题，你能答出来吗？

```java
-7 % 3 = ?
1
```

那这个呢？

```java
7 % (-3) = ？
1
```

正整数的取模大家应该玩的很溜了，(什么，正数的都不会，那自己去谷歌吧，百度也行。) 对于负数呢，上周有人在一个群里问这个问题，我以为我是会的，后来发现我的答案是错的，索性就去研究了一番。

带着问题我打开了[维基百科](https://so.csdn.net/so/search?q=维基百科&spm=1001.2101.3001.7020) https://en.wikipedia.org/wiki/Modulo_operation ，看到了这段话。

在几乎所有的计算系统中，[取模运算](https://so.csdn.net/so/search?q=取模运算&spm=1001.2101.3001.7020)都满足下面这个公式：

```
a = nq + r  |r| < |a|
假设 q 是 a、b 相除得到的商(quotient)，r 是相应的余数(remainder)
12
```

然而，取模操作又依赖于编程语言和底层硬件。

我们现在用这个工具地址 https://c.runoob.com/ 打开我学习的语言，比如 Java/C，会发现

```java
-7 % 3 = -1
7 % (-3) = 1 
12
```

既然编程语言决定了结果，那换一种语言，比如 Python，发现结果竟然真的不一样，你说神奇不神奇。

```python
-7 % 3 = 2
7 % (-3) = -2
12
```

这是为什么呢？

我们知道，当余数不为 0 的时候，取整除(符号是「/」，叫法不一样，可以纠正我一下)，可能出现多种方式，下面是一些你应该知道的例子。

**向上取整**。向 +∞ 方向取最接近精确值的整数，也就是取比实际结果稍大的最小整数，也叫 Ceiling 取整。这种取整方式下，

```
17 / 10 = 2，5 / 2 = 3, -9 / 4 = -2
1
```

**向下取整**。向 -∞ 方向取最接近精确值的整数，也就是取比实际结果稍小的最大整数，也叫 Floor 取整。这种取整方式下，

```
17 / 10 = 1，5 / 2 = 2, -9 / 4 = -3
1
```

**向零取整**。向 0 方向取最接近精确值的整数，换言之就是舍去小数部分，因此又称截断取整（Truncate）。这种取整方式下，

```
17 / 10 = 1，5 / 2 = 2, -9 / 4 = -2
1
```

我们再来看刚才的公式

```
a = nq + r 
我们知道商 q = a/n，从而得出
r = a - (a/n) * n
而 (a/n) 这个结果取决于上面几种方式用哪个
1234
```

下面我们就重点看这个 (a/n)

常用的计算机语言用的除法方式是下面这两种，**truncate 除法** 和 **floor 除法**。

**truncate 除法** 即是上面的向零取整，也叫趋零截尾，而 **floor 除法** 即是上面的向下取整，也叫趋负无穷截尾。

而 Java/C 等语言用的是 truncate 除法，Python 用的是 floor 除法。

这下就明白了吧，现在我们再来看开始的面试题。

在 Java/C 中，

```java
-7 % 3 = -1
7 % (-3) = 1 
// 下面是推倒过程
-7 % 3 = -7 - trunc(-7/3) * 3 = -7 - (-2) * 3 = -7 + 6 = -1
7 % (-3) = 7 - trunc(7 / (-3)) * (-3) = 7 - (-2) * (-3) = 7 - 6 = 1
12345
```

在 Python 中，

```python
-7 % 3 = 2
7 % (-3) = -2
## 下面是推倒过程
-7 % 3 = -7 - floor(-7/3) * 3 = -7 - (-3) * 3 = -7 + 9 = 2
7 % (-3) =  7 - floor(7 / (-3)) * (-3) = 7 - (-3) * (-3) = 7 - 9 = -2
12345
```

如果是其他语言，先去搞清楚是用的那种方式。