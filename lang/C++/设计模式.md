[toc]

# 1 类与类之间的关系

## 1.1 继承关系

继承也叫作泛化（Generalization），用于描述父子类之间的关系，父类又称为基类或者超类，子类又称为派生类，在 UML 中，泛化关系使用 ==带空心三角的实线== 来表示

继承的关系一共有两种：==普通继承关系== 和 ==抽象继承关系==

示例代码如下：

```c++
class Bird {
// 这里为了保护成员属性，同时将使得成员属性可以被继承，所以将其设置为protected
protected:
    string name;
    string sex;
public:
    string getName() {
        return name;
    }

    void setName(string name) {
        this->name = name;
    }
    virtual void fly() {}

    virtual void eat() {}

};

class Cuckoo : public Bird {
public:
    void fly() override {
        cout << "布谷鸟在用翅膀飞行" << endl;
    }

    void eat() override {
        cout << "布谷鸟在吃肉肉的虫子" << endl;
    }
};

class Eagle : public Bird {
public: 
    void fly() override {
        cout << "老鹰在展翅翱翔" << endl;
    }

    void eat() override {
        cout << "老鹰抓小动物吃" << endl;
    }
};
```

对应类图为：

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230424111045106.png" alt="image-20230424111045106" style="zoom: 33%;" />



## 1.2 关联关系

关联关系（Association）是类与类中最常见的关系，是一种结构化关系，表示一个对象与另一个对象之间有联系，例如汽车和轮胎、人和心脏、班级与学生。在 UML 类图 中，使用 ==带箭头或不带箭头的实线== 表示。在 C++ 中，关联关系的表现为：<strong style="color:orange">将一个类的对象作为另一个类的成员变量</strong>

关联关系可以分为如下三类：

1. 单向关联
2. 双向关联
3. 自关联

> 区别体现在箭头的方向性

### 1.2.1 单向关联关系

单向关联关系只是关联是单向的，类似于 "你中有我，但我中未必有你"，比如每个孩子（Child）都拥有一个父亲（Parent）

```c++
class Parent {};

class Child {
private:
    Parent father;
};
```

类图如下：

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230511234153984.png" alt="image-20230511234153984" style="zoom:50%;" />



### 1.2.2 双向关联关系

"你中有我，我中有你"，如下应用场景：每个孩子都有父母，每个父母也都有自己的孩子

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230511234458455.png" alt="image-20230511234458455" style="zoom:50%;" />



### 1.2.3 自关联关系

自关联关系即 ==当前类中包含一个自身类型的对象成员==

我们以双向链表为例：

```c++
class Node
{
private:
    void *data;
    Node *prev;
    Node *next;
};
```

类图如下：

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230512000726906.png" alt="image-20230512000726906" style="zoom: 67%;" />



## 1.3 聚合关系（Aggregation）

聚合关系表示**整体和部分**的关系，在聚合关系，成员对象是整体的一部分，但是成员对象可以脱离整体对象而存在，例如：

- 汽车（Car）与 引擎（Engine）、轮胎（Wheel）、车灯（Light）
- 森林（Forest）与 植物（Plant）、动物（Animal）、水（Water）、阳光（Sunshine）

```c++
class Plant
{
};

class Animal
{
};

class Water
{
};

class Sunshine
{
};

class Forest
{
private:
    Plant plant;
    Animal animal;
    Water water;
    Sunshine sun;

public:
    Forest(Plant &plant, Animal &animal, Water &water, Sunshine &sun) : plant(plant), animal(animal), water(water), sun(sun) {}
};
```

类图如下：

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230512003713592.png" alt="image-20230512003713592" style="zoom:50%;" />

说明：当组成 forest 类的成员对象被创建或被销毁时，forest 实例并不会同时被创建起来或被销毁掉，所以它们只是组合关系



## 1.4 组合关系（Composition）

组合关系代表的也是**整体和部分的关系**，与聚合关系不同的是，组合关系的整体和部分关系比较紧密，一旦整体对象不存在，那么成员对象也不复存在，两者是 "同生共死" 的关系，例如：

- 头（Head）和 嘴巴（Mouth）、鼻子（Nose）、耳朵（Ear）、眼睛（Eye）
- 树（Tree）和 树根（Root）、树干（Trunk）、树枝（Branch）、树叶（Leaf）

**示例代码**

```c++
class Mouth
{
};

class Nose
{
};

class Ear
{
};

class Eye
{
};

class Head
{
private:
    Mouth *mouth;
    Nose *nose;
    Ear *ear;
    Eye *eye;

public:
    // 当Head被创建时，Head的成员对象也会被随之创建
    Head() {
        mouth = new Mouth;
        nose = new Nose;
        ear = new Ear;
        eye = new Eye;
    }

    // 当Head被销毁时，Head的成员对象也会被随之销毁
    ~Head() {
        delete mouth;
        delete nose;
        delete ear;
        delete eye;
    }
};
```

类图如下：

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230512085753233.png" alt="image-20230512085753233" style="zoom:50%;" />



## 1.5 依赖关系（dependency）

依赖关系其实就是一种使用关系，可以体现在三种情景：

1. 将一个类的对象作为另一个类中方法的参数
2. 在一个类的方法中将另一个类的对象作为其对象的局部变量
3. 在一个类的方法中调用另一个类的静态方法

> 类之间的关系强弱顺序：继承 > 组合 > 聚合 > 关联 > 依赖；
>
> > 关联关系看上去和依赖关系十分类似，我们甚至可以将关联关系看做是 "强烈" 的依赖关系，两者最主要的区别除了分类以及表示不同，我们可以用一句话来概括就是：<strong style="color:red">依赖关系是==使用==关系，而关联关系是==拥有==的关系</strong>

例如：大树需要借助水、空气和土壤茁壮成长

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230512092459256.png" alt="image-20230512092459256" style="zoom:50%;" />



**代码实现**

```c++
class Water
{
};

class Air
{
};

class Soil
{
};

class Tree
{
public:
    void grow(Water w, Air a, Soil s) 
    {
        cout << "借助 w 中的水分, s 中的养分和 a 中的二氧化碳, 我就可以茁壮成长了";
    }
};
```



# 2 设计模式原则

- 单一职责原则：一个类应只承担一个职责，不能 "身兼数职"，将所有在职责耦合到一起

- 开放封闭原则：<strong style="color:red">对扩展开发，对修改关闭</strong>

- 依赖倒转原则：

  1. 高层模块不应该依赖低层模块，两者都应该依赖抽象

  2. 抽象不应该依赖细节，细节应该依赖抽象

     > 细节是多态在子类重写父类虚函数的时候实现的

- 里氏代换原则：即<strong style="color:red">子类类型应能够完全替换父类类型</strong>，也即在多态里确保父类引用能够指向子类，显然，如果不满足里氏代换原则，那么依赖倒转原则的第二条也是不能够满足的

>设计模式一共有 6 种，分别是：单一职责原则、开闭原则、迪米特原则、依赖倒置原则、接口隔离原则、里式替换原则。
>
>> 其中里式替换原则是指 "任何父类出现的地方，我们都可以使用子类替代"，而迪米特原则，我们也称其为 "最少知道原则"，即一个类对其他类应该有最少了解



我们对依赖倒转原则再进行详细说明：

1. 抽象类中提供的接口是固定不变的
2. 低层模块是抽象类的子类，继承了抽象类的接口，并且可以重写这些接口的行为
3. 高层模块想要实现某些功能，调用的是抽象类中的函数接口，并且是通过抽象类中父类指针引用指向子类实例，完成多态

![image-20230512103747986](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230512103747986.png)



# 3 创建型模式

## 3.1 单例模式

在一个项目中，全局范围内，某个类的实例有且仅有一个，通过这个唯一实例向其他模块提供数据的全局访问，这种模式就叫做单例模式。单例模式最经典的应用就是任务队列。

由于一个类中默认存在无参构造器、拷贝构造器和移动构造器，而前两种会创建出新的实例，所以我们需要将其关闭或删除

```c++
class TaskQueue {
private:
    TaskQueue() = default;
    TaskQueue(const TaskQueue& t) = default;
};
```

**或者**

```c++
class TaskQueue {
public:
    TaskQueue() = delete;
    TaskQueue(const TaskQueue& t) = delete;
};
```



**创建单例示例代码**

```c++
class TaskQueue
{
public:
    TaskQueue(const TaskQueue &t) = delete;            // 删除拷贝构造函数
    TaskQueue &operator=(const TaskQueue &t) = delete; // 删除赋值拷贝
    static TaskQueue *getInstance()
    {
        return m_taskQueue;
    }
    void print()
    {
        cout << "I am a singleton object" << endl;
    }

private:
    TaskQueue() = default;
    // 只能通过类名访问静态属性或方法
    static TaskQueue *m_taskQueue;
};
TaskQueue *TaskQueue::m_taskQueue = new TaskQueue;
```

> 注意事项：
>
> 1. 静态成员只能类内定义，类外初始化
> 2. 为了保证只能从类中拿到一个单例，需要删除（或关闭）拷贝构造函数和赋值重载函数，默认的无参构造只能关闭，不能删除，因为后面初始化时需要使用到 



### 3.1.1 饿汉式和懒汉式

- 饿汉式：在类加载的时候就立即实例化（上述代码就是一个典型的饿汉式）
- 懒汉式：在类加载的时候不去创建该单例，而是在需要使用的时候再进行实例化

**懒汉式示例代码**

```c++
class TaskQueue
{
public:
    TaskQueue(const TaskQueue &t) = delete;
    TaskQueue &operator=(const TaskQueue &t) = delete;
    static TaskQueue* getInstance()
    {
        // 在调用获取单例方法时才进行创建单例
        if (m_taskQueue == nullptr) {
            m_taskQueue = new TaskQueue;
        }
        return m_taskQueue;
    }
    void print()
    {
        cout << "I am a singleton object" << endl;
    }

private:
    TaskQueue() = default;
    static TaskQueue* m_taskQueue;
};
TaskQueue* TaskQueue::m_taskQueue = nullptr;
```

现在我们将多线程考虑进来，显然饿汉式由于在类加载之初就创建单例，利用类的加载机制避免多线程下可能会出现由于线程竞争导致创建多个单例的问题，但是上述的饿汉式就很有可能会出现该问题，因此线程不安全



### 3.1.2 线程安全的懒汉式

为了使得上述的懒汉式能够做到线程安全，我们可以考虑使用互斥锁，将其变成线程安全的懒汉式，如下：

```c++
class TaskQueue
{
public:
    TaskQueue(const TaskQueue& t) = delete;
    TaskQueue& operator=(const TaskQueue& t) = delete;
    static TaskQueue* getInstance()
    {
        // 加锁
        m_mutex.lock();
        if (m_taskQueue == nullptr) {
            m_taskQueue = new TaskQueue;
        }
        // 解锁
        m_mutex.unlock();
        return m_taskQueue;
    }
    void print()
    {
        cout << "I am a singleton object" << endl;
    }

private:
    TaskQueue() = default;
    static TaskQueue* m_taskQueue;
    // 添加一个锁的对象
    static mutex m_mutex;
};
TaskQueue* TaskQueue::m_taskQueue = nullptr;
mutex TaskQueue::m_mutex;
```

> 注意事项：
>
> 1. 使用 c++11 新特性的互斥锁之前，我们需要先引入 `<mutex>` 头文件
> 2. 上面的写法虽然解决了线程安全的问题，但是效率极低，不推荐使用



### 3.1.3 双重检查锁定——懒汉式（doubleCheck）

```c++
class TaskQueue
{
public:
    TaskQueue(const TaskQueue& t) = delete;
    TaskQueue& operator=(const TaskQueue& t) = delete;
    static TaskQueue* getInstance()
    {
        if (m_taskQueue == nullptr) {   // 给锁也加了一层判断
            m_mutex.lock();
            if (m_taskQueue == nullptr) {
                m_taskQueue = new TaskQueue;
            }
            m_mutex.unlock();
        }

        return m_taskQueue;
    }
    void print()
    {
        cout << "I am a singleton object" << endl;
    }

private:
    TaskQueue() = default;
    static TaskQueue* m_taskQueue;
    // 添加一个锁的对象
    static mutex m_mutex;
};
TaskQueue* TaskQueue::m_taskQueue = nullptr;
mutex TaskQueue::m_mutex;
```

:thought_balloon:**分析**

当我们在锁的外层**添加一层判空**后，假设 A、B、C 三个线程同时进入 `getInstance()` 方法，A 线程通过 if 语句后加锁并创建实例后解锁，B、C 线程之后就无法通过第一层判断，直接将单例返回，显然比前面**无论如何都要走一遍加锁和解锁操作**效率高多了



### 3.1.4 原子变量解决双重检查锁定问题

上面的程序代码看上去好像没有问题，但是如果从底层看，还是具有 bug 的，因为实际上 `m_taskQ = new TaskQueue` 在执行过程中`对应的机器指令可能会被重新排序`。正常过程如下：

- 第一步：分配内存用于保存 `TaskQueue` 对象。
- 第二步：在分配的内存中构造一个 `TaskQueue` 对象（初始化内存）。
- 第三步：使用 `m_taskQueue` 指针指向分配的内存。

但是被重新排序以后执行顺序可能会变成这样：

- 第一步：分配内存用于保存 `TaskQueue` 对象。
- 第二步：使用 `m_taskQueue` 指针指向分配的内存。
- 第三步：在分配的内存中构造一个 `TaskQueue` 对象（初始化内存）。

c++11 引入了原子变量 atomic，通过原子变量我们可以实现一种更安全的懒汉模式的单例，代码实现如下：

```c++
class TaskQueue
{
public:
    TaskQueue(const TaskQueue& t) = delete;
    TaskQueue& operator=(const TaskQueue& t) = delete;
    static TaskQueue* getInstance()
    {
        // 取出 TaskQueue* 对象
        TaskQueue* task = m_taskQueue.load();
        if (task == nullptr) {
            m_mutex.lock();
            // 再次取出（在多线程竞争的情况下）
            task = m_taskQueue.load();
            if (task == nullptr) {
               // 将对象创建出来并放回原子
                task = new TaskQueue;
                m_taskQueue.store(task);
            }
            m_mutex.unlock();
        }

        return m_taskQueue;
    }
    void print()
    {
        cout << "I am a singleton object" << endl;
    }

private:
    TaskQueue() = default;
    static atomic<TaskQueue*> m_taskQueue;
    // 添加一个锁的对象
    static mutex m_mutex;
};
atomic<TaskQueue*> TaskQueue::m_taskQueue = nullptr;
mutex TaskQueue::m_mutex;
```

> 注意事项：务必要添加头文件 `<atomic>`



### 3.1.5 静态局部对象实现线程安全

我们除了使用双重检查锁定的方式来解决懒汉式线程不安全，还可以使用一种更为简单的方式，即使用静态局部对象，代码实现如下：

```c++
class TaskQueue
{
public:
    TaskQueue(const TaskQueue& t) = delete;
    TaskQueue& operator=(const TaskQueue& t) = delete;
    static TaskQueue* getInstance()
    {
        static TaskQueue m_taskQueue;
        return &m_taskQueue;
    }
    void print()
    {
        cout << "I am a singleton object" << endl;
    }

private:
    TaskQueue() = default;
};
```

可以看到，相较于前面的解决方案，使用静态局部对象的写法显得十分优雅，<strong style="color:red">在代码的第 8 行定义了一个未被初始化的静态局部队列对象，并且将这个对象作为了单例</strong>，这种方式底层原理源于 C++11 标准的规定，并且该操作是在编译时由编译器保证的：

>如果指令逻辑进入一个未被初始化的声明变量，所有并发执行应当等待该变量完成初始化。



### 3.1.6 模拟一个多线程下的任务对列

```c++
#include <iostream>
#include <mutex>
#include <queue>
using namespace std;

class TaskQueue {
public: 
	TaskQueue(const TaskQueue& t) = delete;
	TaskQueue& operator=(const TaskQueue& t) = delete;
	static TaskQueue* getInstance() {
		static TaskQueue task;
		return &task;
	}
	// 判断任务对列是否为空
	bool isEmpty() {
		lock_guard<mutex> locker(m_mutex);
		return m_data.empty();
	}

	// 添加任务
	void addTask(int node) {
		lock_guard<mutex> locker(m_mutex);
		m_data.push(node);
	}

	// 删除任务
	bool popTask() {
		lock_guard<mutex> locker(m_mutex);
		if (m_data.empty()) {
			return false;
		}
		m_data.pop();
		return true;
	}

	// 取出任务
	int takeTask() {
		lock_guard<mutex> locker(m_mutex);
		if (m_data.empty()) {
			return -1;
		}
		return m_data.front();
	}
private:
	TaskQueue() = default;
	// 定义任务队列
	queue<int> m_data;
	mutex m_mutex;
};

int main() {
	TaskQueue* taskQ = TaskQueue::getInstance();
	// 生产者线程
	thread t1([=]() {
		for (int i = 0; i < 100; ++i) {
			taskQ->addTask(i);
			cout << "push data = " << i << ", threadID = " << this_thread::get_id() << endl;
			this_thread::sleep_for(chrono::milliseconds(500));
		}
	});

	// 消费者线程
	thread t2([=]() {
		this_thread::sleep_for(chrono::milliseconds(100));
		while (!taskQ->isEmpty()) {
			int data = taskQ->takeTask();
			cout << "take data = " << data << ", threadID = " << this_thread::get_id() << endl;
			taskQ->popTask();
			this_thread::sleep_for(chrono::milliseconds(1000));
		}
	});

	t1.join();	// 将 t1 加入主线程
	t2.join();	// 将 t2 加入主线程

	return 0;
}
```



### 3.1.7 单例模式类图

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230512191101440.png" alt="image-20230512191101440" style="zoom:50%;" />



## 3.2 工厂模式

### 3.2.1 简单工厂模式

简单工厂模式相关的类的创建和使用步骤如下：

1. 创建一个工厂类

   > 对于简单工厂模式而言，需要的工厂类仅一个

2. 在工厂类中添加 `public` 的成员函数，该成员函数帮助我们生产实例对象

3. 使用的方式：只需要创建工厂对象，然后通过该工厂对象调用工厂函数，这样就可以生产出一个指定类型的实例对象

**类图**

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230512214807917.png" alt="image-20230512214807917" style="zoom:50%;" />



**代码实现**

```c++
#include <iostream>
using namespace std;

// 产品的父类 —— 人造恶魔果实
class AbstractSmile
{
public:
    virtual void transform() = 0;
    virtual void ability() = 0;
    virtual ~AbstractSmile() {}	// 这里之所以要将父类的析构函数设置为虚函数，是为了子类能够调用自己的析构函数
};

// 羊果实
class SheepSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 —— 山羊形态..." << endl;
    }

    void ability() override
    {
        cout << "将手臂变成绵羊角的招式 —— 巨羊角" << endl;
    }
};

// 狮子果实
class LionSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 狮子人形态..." << endl;
    }
    void ability() override
    {
        cout << "火遁· 豪火球之术..." << endl;
    }
};

// 蝙蝠果实
class BatSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 蝙蝠人形态..." << endl;
    }
    void ability() override
    {
        cout << "声纳引箭之万剑归宗..." << endl;
    }
};

// 定义强类型枚举
enum class Type :char
{
    SHEEP,
    LION,
    BAT
};

// 创建恶魔果实的简单工厂
class SimleFactory
{
public:
    // 提供创建工厂创建方法
    AbstractSmile* createSmile(Type type)
    {
        AbstractSmile* smile = nullptr;
        switch (type)
        {
        case Type::SHEEP:
            smile = new SheepSmile;
            break;
        case Type::LION:
            smile = new LionSmile;
            break;
        case Type::BAT:
            smile = new BatSmile;
            break;
        default:
            break;
        }

        return smile;
    }
};

int main()
{
    SimleFactory* factory = new SimleFactory;
    AbstractSmile* smile = factory->createSmile(Type::LION);
    smile->ability();
    smile->transform();

    return 0;
}
```



### 3.2.2 工厂模式

我们对简单工厂模式进行分析，简单工厂模式的优点很明显，就是十分简单，只有**一个工厂**，该工厂生产各类产品，缺点就是**违反了开放封闭原则**，<u>当产品很多时，我们在增添产品类的同时，不仅需要修改简单工厂类，还需要修改产品枚举类</u>

我们将其做改进，使用工厂模式，即<strong style="color:red">创建多个工厂，每个工厂仅负责创建某一种产品，并且这些工厂都要继承抽象工厂</strong>

> 工厂方法模式定义了一个创建类的接口，让子类去决定实例化哪一个对象。让对象的实例化延迟到其子类执行





<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230512224621013.png" alt="image-20230512224621013" style="zoom:50%;" />

**代码实现**

```c++
#include <iostream>
using namespace std;

// 产品的父类 —— 人造恶魔果实
class AbstractSmile
{
public:
    virtual void transform() = 0;
    virtual void ability() = 0;
    virtual ~AbstractSmile() {}	// 这里之所以要将父类的析构函数设置为虚函数，是为了子类能够调用自己的析构函数
};

// 羊果实
class SheepSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 —— 山羊形态..." << endl;
    }

    void ability() override
    {
        cout << "将手臂变成绵羊角的招式 —— 巨羊角" << endl;
    }
};

// 狮子果实
class LionSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 狮子人形态..." << endl;
    }
    void ability() override
    {
        cout << "火遁· 豪火球之术..." << endl;
    }
};

// 蝙蝠果实
class BatSmile : public AbstractSmile
{
public:
    void transform() override
    {
        cout << "变成人兽 -- 蝙蝠人形态..." << endl;
    }
    void ability() override
    {
        cout << "声纳引箭之万剑归宗..." << endl;
    }
};

// 创建恶魔果实的工厂
class AbstractFactory
{
public:
    // 提供创建工厂创建方法
    virtual AbstractSmile* createSmile() = 0;
    virtual ~AbstractFactory() {}
};

// 生成羊恶魔果实的工厂
class SheepFactory : public AbstractFactory
{
public:
    AbstractSmile* createSmile()
    {
        return new SheepSmile;
    }

    ~SheepFactory()
    {
        cout << "SheepFactory 被析构了" << endl;
    }
};

// 生成狮子恶魔果实的工厂
class LionFactory : public AbstractFactory
{
public:
    AbstractSmile* createSmile()
    {
        return new LionSmile;
    }

    ~LionFactory()
    {
        cout << "LionFactory 被析构了" << endl;
    }
};

// 生成蝙蝠恶魔果实的工厂
class BatFactory : public AbstractFactory
{
public:
    AbstractSmile* createSmile()
    {
        return new BatSmile;
    }

    ~BatFactory()
    {
        cout << "BatFactory 被析构了" << endl;
    }
};

int main()
{
    // 创建能够生产狮子恶魔果实的工厂实例
    AbstractFactory* factory = new LionFactory();
    // 创建狮子恶魔果实
    AbstractSmile* smile = factory->createSmile();
    smile->transform();
    smile->ability();

    return 0;
}
```



### 3.2.3 抽象工厂模式

其实无论是工厂模式还是简单工厂模式，它们本质都没区别，创建的产品都是直接创建，产品本身并没有划分类别细分，接下来我们介绍抽象工厂模式，该模式生成的产品则更加复杂

<u>示例：使用抽象工厂模式创建如下三种船型</u>

> 抽象工厂模式用于提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类

|      | 基础型 | 标准型 | 旗舰型   |
| ---- | ------ | ------ | -------- |
| 船体 | 木头   | 钢铁   | 合成金属 |
| 动力 | 手动   | 内燃机 | 核能     |
| 武器 | 枪     | 速射炮 | 激光     |

**类图**

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg" alt="抽象工厂模式" style="zoom:50%;" />

**代码实现**

01 准备建立船的材料

```c++
// -------------船体
class ShipBody
{
public:
	virtual string getShipBody() = 0;
	~ShipBody() {}
};

// 船体：木头
class WoodBody : public ShipBody
{
public:
	string getShipBody() override
	{
		return string("使用<木头>船体");
	}
};

// 船体：钢铁
class IronBody : public ShipBody
{
public:
	string getShipBody() override
	{
		return string("使用<钢铁>船体");
	}
};

// 船体：合成金属
class MetalBody : public ShipBody
{
public:
	string getShipBody() override
	{
		return string("使用<合成金属>船体");
	}
};

// -------------动力
class Engine
{
public:
	virtual string getEngine() = 0;
	virtual ~Engine() {}
};

// 动力：人力
class Human : public Engine
{
public:
	string getEngine() override
	{
		return string("使用<人力>动力");
	}
};

// 动力：内燃机
class Diesel : public Engine
{
public:
	string getEngine() override
	{
		return string("使用<内燃机>动力");
	}
};

// 动力：核能
class Nuclear : public Engine
{
public:
	string getEngine() override
	{
		return string("使用<核能>动力");
	}
};

// -------------武器
class Weapon
{
public:
	virtual string getWeapon() = 0;
	virtual ~Weapon() {}
};

// 武器：枪
class Gun : public Weapon
{
public:
	string getWeapon() override
	{
		return string("配备的武器是<枪>");
	}
};

// 武器：速射炮
class Cannon : public Weapon
{
public:
	string getWeapon() override
	{
		return string("配备的武器是<自动机关炮>");
	}
};

// 武器：激光枪
class Laser : public Weapon
{
public:
	string getWeapon() override
	{
		return string("配备的武器是<激光>");
	}
};
```



02 建立轮船（轮船由各种材料组成）

```c++
class Ship
{
public:
	Ship(ShipBody* body, Engine* engine, Weapon* weapon): m_body(body), m_engine(engine), m_weapon(weapon)
	{}

	void getProperty()
	{
		string info = m_body->getShipBody() + ", " + m_engine->getEngine() + ", " + m_weapon->getWeapon();
		cout << info << endl;
	}

	// 使 ship 和 ShipBody、Engine、Weapon 形成组合关系
	~Ship()
	{
		delete m_body;
		delete m_engine;
		delete m_weapon;
	}
private:
	ShipBody* m_body;
	Engine* m_engine;
	Weapon* m_weapon;
};
```



03 创建工厂

```c++
// 抽象工厂类
class AbstractFactory
{
public:
	virtual Ship* createShip() = 0;

	virtual ~AbstractFactory() {}
};

// 生产基础船型
class BasicShipFactory : public AbstractFactory
{
public:
	Ship* createShip() override
	{
		return new Ship(new WoodBody, new Human, new Gun);
	}

	~BasicShipFactory()
	{
		cout << "基础船型被销毁" << endl;
	}
};

// 生产标准船型
class StandardShipFactory : public AbstractFactory
{
	Ship* createShip() override
	{
		return new Ship(new IronBody, new Diesel, new Cannon);
	}

	~StandardShipFactory()
	{
		cout << "标准船型被销毁" << endl;
	}
};

// 生产旗舰型船型
class UltimateShipFactory : public AbstractFactory
{
public:
	Ship* createShip() override
	{
		return new Ship(new MetalBody, new Nuclear, new Laser);
	}

	~UltimateShipFactory()
	{
		cout << "旗舰船型被销毁" << endl;
	}
};
```



04 测试代码

```c++
// 创建一个生产标准船型的工厂
AbstractFactory* stanardFactory = new StandardShipFactory;
Ship* standardShip = stanardFactory->createShip();
standardShip->getProperty();

// 创建一个旗舰型船型的工厂
AbstractFactory* UltimateFactoy = new UltimateShipFactory;
Ship* ultimateShip = UltimateFactoy->createShip();
ultimateShip->getProperty();
```



:spiral_notepad:**总结**

1. 简单工厂模式不能遵守 ==开放-封闭== 原则，而工厂模式和抽象工厂模式遵守
2. 简单工厂模式只有一个工厂类，而抽象工厂模式有多个工厂类
3. 工厂模式创建的产品相对简单，而抽象工厂模式创建的产品复杂
   - 工厂模式创建的对象对应的类不需要提供抽象类【这产品类组件中没有可变因素】
   - 抽象工厂模式创建的对象对应的类有抽象的基类【这个产品类组件中有可变因素】



## 3.3 建造者模式 / 生成器模式

生成器模式分步骤创建复杂的对象，并且允许使用相同的代码生成不同类型和形式的对象

生成器模式建议将造船工序的代码从产品类中抽取出来，并将其放在一个名为==生成器==的独立类中

> 让一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示



<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230513161300500.png" alt="image-20230513161300500" style="zoom: 50%;" />

生成器中有一系列的构建步骤，每次造船时，只需要从中选择需要的步骤并进行调用即可，但是有一点就是==生成器内部的构建步骤不变==

假设现在我们要按照如下规格建造船，当然我们可以使用前面的抽象工厂模式，但是现在要求体现建造的细节，所以这里我们使用生成器模式

|      | 简约型 | 标准型 | 豪华型 |
| ---- | ------ | ------ | ------ |
| 船体 | 有     | 有     | 有     |
| 动力 | 有     | 有     | 有     |
| 武器 | 无     | 有     | 有     |
| 内室 | 毛坯   | 毛坯   | 精装   |

并且我们想要建造两种型号，==桑尼号==和==梅利号==，并且按上面的三种规格，每种造一艘，那么此时我们就需要两个生成器：==桑尼号生成器==和==梅利号生成器==，并且这两个生成器需要对应一个父类

**主管类**

将用于创建产品的一系列生成器步骤调用抽取成为单独的`主管类`。 <u>主管类可定义**创建步骤的执行顺序以及控制是否执行某些步骤**， 而生成器则提供这些步骤的实现。</u>



**类图**

![image-20230607190019289](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230607190019289.png)



**代码实现**

01 定义船相关类

```c++
// 定义 sunny 号船
class SunnyShip
{
public:
	void addParts(string name)
	{
		m_parts.push_back(name);
	}

	void showParts()
	{
		for (const auto& item : m_parts)
		{
			cout << item << " ";
		}
		cout << endl;
	}
private:
	vector<string> m_parts;
};

// 定义梅尼号
class MerryShip
{
public:
	// 添加的武器位置和武器名
	void assemble(string pos, string name)
	{
		m_parts.insert(make_pair(pos, name));
	}

	void showParts()
	{
		for (const auto& item : m_parts)
		{
			cout << item.first << ": " << item.second << " ";
		}
		cout << endl;
		
	}
private:
	map<string, string> m_parts;
};
```



02 定义生成器

生成器中封装了实现创建产品 "零部件" 的步骤

```c++
// 抽象生成器
class ShipBuilder
{
public:
	virtual void reset() = 0;
	virtual void buildBody() = 0;
	virtual void buildWeapon() = 0;
	virtual void buildEngine() = 0;
	virtual void buildInterior() = 0;
	virtual ~ShipBuilder() {}
};

class SunnyBuilder : public ShipBuilder
{
public:
	SunnyBuilder()
	{
		reset();
	}
	~SunnyBuilder()
	{
		if (sunnyShip != nullptr)
		{
			delete sunnyShip;
		}
	}
	void reset() override
	{
		sunnyShip = new SunnyShip;
	}
	void buildBody() override
	{
		sunnyShip->addParts("神树亚当的树干");
	}
	void buildWeapon() override
	{
		sunnyShip->addParts("狮吼炮");
	}
	void buildEngine() override
	{
		sunnyShip->addParts("可乐驱动");
	}
	void buildInterior() override
	{
		sunnyShip->addParts("豪华内室精修");
	}
	SunnyShip* getSunnyShip()
	{
		SunnyShip* ship = sunnyShip;
		sunnyShip = nullptr;
		return ship;
	}
private:
	SunnyShip* sunnyShip;
};

class MerryBuilder : public ShipBuilder
{
public:
	MerryBuilder()
	{
		reset();
	}
	~MerryBuilder()
	{
		if (merryShip != nullptr)
		{
			delete merryShip;
		}
	}
	void reset() override
	{
		merryShip = new MerryShip;
	}
	void buildBody() override
	{
		merryShip->assemble("船体", "神树亚当的树干");
	}
	void buildWeapon() override
	{
		merryShip->assemble("武器", "狮吼炮");
	}
	void buildEngine() override
	{
		merryShip->assemble("引擎", "可乐驱动");
	}
	void buildInterior() override
	{
		merryShip->assemble("室内装修", "豪华内室精修");
	}
	MerryShip* getSunnyShip()
	{
		MerryShip* ship = merryShip;
		merryShip = nullptr;
		return ship;
	}
private:
	MerryShip* merryShip;
};
```



03 主管类

主管类控制创建轮船类型（轮船的组成）

```c++
class Director
{
public:
	void setBuilder(ShipBuilder* builder)
	{
		shipBuilder = builder;
	}
	// 创建简约型
	void createSimpleShip()
	{
		shipBuilder->buildBody();
		shipBuilder->buildEngine();
	}

	// 创建标准型（配备武器）
	void createStandardShip()
	{
		createSimpleShip();
		shipBuilder->buildWeapon();
	}

	// 创建豪华型（配置武器同时配置了室内）
	void createRegalShip()
	{
		createStandardShip();
		shipBuilder->buildInterior();
	}
private:
	ShipBuilder* shipBuilder = nullptr;
};
```



04 测试程序

```c++
void createSunnyShip()
{
	// 创建一个主管类
	Director* director = new Director;
	// 创建 sunnyBuilder 
	SunnyBuilder* sunnyBuilder = new SunnyBuilder;

	// 创建一个简约型的桑尼船
	director->setBuilder(sunnyBuilder);
	director->createSimpleShip();
	SunnyShip* sunnyShip = sunnyBuilder->getSunnyShip();
	sunnyShip->showParts();

	// 创建一个标准型的桑尼船
	sunnyBuilder->reset();	// 其实这里也可以先 delete 释放掉 sunnyBuilder，但是为了节省性能，所以使用同一个builder
	director->setBuilder(sunnyBuilder);
	director->createStandardShip();
	sunnyShip = sunnyBuilder->getSunnyShip();
	sunnyShip->showParts();

	// 创建一个豪华型的桑尼船
	sunnyBuilder->reset();
	director->setBuilder(sunnyBuilder);
	director->createRegalShip();
	sunnyShip = sunnyBuilder->getSunnyShip();
	sunnyShip->showParts();
}
```

```c++
void createMerryShip()
{
	// 创建主管类
	Director* director = new Director;
	// 创建 merryBuilder
	MerryBuilder* merryBuilder = new MerryBuilder;
	
	// 创建一个简约型的梅丽船
	director->setBuilder(merryBuilder);
	director->createSimpleShip();
	MerryShip* merryShip = merryBuilder->getSunnyShip();
	merryShip->showParts();

	// 创建一个标准型的梅丽船
	merryBuilder->reset();
	director->setBuilder(merryBuilder);
	director->createStandardShip();
	merryShip = merryBuilder->getSunnyShip();
	merryShip->showParts();

	// 创建一个豪华型的梅丽船
	merryBuilder->reset();
	director->setBuilder(merryBuilder);
	director->createRegalShip();
	merryShip = merryBuilder->getSunnyShip();
	merryShip->showParts();
}
```



## 3.4 原型模式

原型模式的本质其实就是==复制 / 克隆==，<strong style="color:red">利用原型模式我们能够复制已有的对象，而又无需使代码依赖他们所属的类</strong>，换言之，就是通过已有的对象克隆出另一个新的对象。

可能你会疑惑：为什么我们需要为了克隆而单独创建一个原型设计模式？直接使用==拷贝构造函数==不好吗？原因如下：

><strong style="color:red">克隆可能会在父类和子类之间进行，并且可能是动态的，很明显通过父类的拷贝构造函数无法实现对子类对象的拷贝</strong>，其实这就是一个多态，我们需要给父类提供一个克隆函数并且是一个虚函数。
>
>> 在 JAVA 中，原型模式的存在其实更多地是为了在创建重复对象的同时，又能够保证性能



**示例代码**

```c++
class GermaSoldier
{
public:
	virtual GermaSoldier* clone() = 0;
	virtual string whoAmI() = 0;
	virtual ~GermaSoldier() {}
};

class Soldier66 : public GermaSoldier
{
public:
	GermaSoldier* clone() override
	{
		return new Soldier66(*this);	// 自身的拷贝构造函数
	}
	
	string whoAmI() override
	{
		return "I am Soldier66";
	}
};

class Soldier67 : public GermaSoldier
{
	GermaSoldier* clone() override
	{
		return new Soldier67(*this);	// 自身的拷贝构造函数
	}

	string whoAmI() override
	{
		return "I am Soldier66";
	}
};
```



**类图**

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230513232924050.png" alt="image-20230513232924050" style="zoom:50%;" />

:warning:**注意事项**

当我们在使用原型设计模式的时候，一定要考虑到 ==深拷贝和浅拷贝== 的问题，如果我们不对类中默认的拷贝构造函数进行改造，那么该**拷贝构造函数默认执行的是浅拷贝**，也就是说当我们同时克隆了很多实例，对其中一个实例的改造或销毁是会影响到其他克隆体的

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          

# 4 结构型模式

## 4.1 适配器模式

适配器模式：将一个类的接口转换成用户希望的另一个接口，使不兼容的对象能够相互配合并一起工作，这种模式就叫适配器模式。

适配器的使用场景：

- STL 标准模板库有六大组件，其中之一的就是适配器。
  - 六大组件分别是：容器、算法、迭代器、仿函数、适配器、空间适配器。
  - 适配器又可以分为：容器适配器、函数适配器、迭代器适配器
- 香港的插座插孔是欧式的，从大陆去香港旅游，就需要带转换头（适配器）



现在，我们需要编写国宝与曾经屠戮它的外国人的对话适配器

01 定义外国人类

```c++
class Foreigner
{
public:
	virtual string confession() = 0;
	void setResult(string msg)
	{
		cout << "大熊猫说：" << msg << endl;
	}
	virtual ~Foreigner() {}
};

class American : public Foreigner
{
public:
	string confession()
	{
		return "我有罪，我是个十恶不赦的罪人";
	}
};

class French : public Foreigner
{
public:
	string confession()
	{
		return "我是畜生，我该死";
	}
};
```



02 定义熊猫类

```c++
class Panda
{
public:
	string sendMessage()
	{
		return "所有强盗、杀人犯都罪不可赦";
	}
	void receiveMessage(string msg)
	{
		cout << msg << endl;
	}
};
```



03 定义适配器类

```c++
class AbstractTranslator
{
public:
	AbstractTranslator(Foreigner* foreigner) : m_foreigner(foreigner) {}
	virtual void translateToPanda() = 0;
	virtual void translateToHuman() = 0;
	virtual ~AbstractTranslator() {}
protected:
	Panda m_panda;
	Foreigner* m_foreigner = nullptr;
};

class AmericanTranslator : public AbstractTranslator
{
public:
	using AbstractTranslator::AbstractTranslator;	// 继承父类的构造函数
	void translateToPanda() override
	{
		string confession = m_foreigner->confession();
		m_panda.receiveMessage("收到美国人忏悔: " + confession);
	}
	void translateToHuman() override
	{
		string msg = m_panda.sendMessage();
		m_foreigner->setResult(msg);
	}
};

class FrenchTranslator : public AbstractTranslator
{
public:
	using AbstractTranslator::AbstractTranslator;	// 继承父类的构造函数
	void translateToPanda() override
	{
		string confession = m_foreigner->confession();
		m_panda.receiveMessage("收到法国人忏悔: " + confession);
	}
	void translateToHuman() override
	{
		string msg = m_panda.sendMessage();
		m_foreigner->setResult(msg);
	}
};
```



04 测试程序

```c++
Foreigner* foreigner = new American;
AbstractTranslator* adpater = new AmericanTranslator(foreigner);
adpater->translateToPanda();
adpater->translateToHuman();
delete adpater;
delete foreigner;
```



类图如下：

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230514102412813.png" alt="image-20230514102412813" style="zoom:50%;" />

> 适配器类在适配器模式其实就是充当 "翻译"(或者说是 "转接口") 的作用，利用适配器类完成不相通类的相互转换，当转换一方没有子类时，我们可以考虑使用继承关系



## 4.2 桥接模式

桥接模式的核心：<strong style="color:red">将抽象与实现分离，使得他们可以独立的变化</strong>

关于使用桥接模式的示例，有如下几类：

1. 空调、电视机等和它们对应的遥控器
   - 空调、电视机是抽象，遥控器是实现

2. 手机品牌和手机软件
   - 手机品牌是抽象，手机软件是实现

3. 跨平台的 GUI 在不同平台上运行
   - 程序的 GUI 层是抽象，操作系统的 API 是实现

例如：现在我们要将海贼船（抽象部分）与船员（实现部分）分离开来

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20220913084352840.png" alt="image-20220913084352840" style="zoom:50%;" />

**类图**

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230514160144332.png" alt="image-20230514160144332" style="zoom:50%;" />

**代码实现**

01 实现部分

```c++
struct Person
{
	Person(string name, string job, string ability, string reward, string beizhu = string("空空如也")) {
		this->name = name;
		this->job = job;
		this->ability = ability;
		this->reward = reward;
		this->beizhu = beizhu;
	}
	string name;
	string job;
	string ability;
	string reward;
	string beizhu;
};

class AbstractTeam
{
public:
	AbstractTeam(string name): t_name(name) {}
	
	void addMember(Person* p)
	{
		m_team.insert(make_pair(p->name, p));
	}

	void showMember()
	{
		for (const auto& item : m_team)
		{
			cout << "[ name: " << item.second->name
				<< ", job: " << item.second->job
				<< ", ability: " << item.second->ability
				<< ", reward: " << item.second->reward
				<< ", beizhu: " << item.second->beizhu << " ]"
				<< endl;
		}
	}

	string getName()
	{
		return t_name;
	}

	virtual void executeTask() = 0;

	virtual ~AbstractTeam()
	{
		for (const auto& item : m_team)
		{
			delete item.second;
		}
	}

protected:
	string t_name;
	map<string, Person*> m_team;
};

// 草帽海贼团
class CaoMaoTeam : public AbstractTeam
{
	using AbstractTeam::AbstractTeam;

	void executeTask() override
	{
		cout << "在海上冒险，找到 ONE PIECE 成为海贼王！" << endl;
	}
};

// 斯摩格海军
class SmokerTeam : public AbstractTeam
{
	using AbstractTeam::AbstractTeam;

	void executeTask() override
	{
		cout << "为了正义, 先将草帽一伙一网打尽!!!" << endl;
	}
};
```



02 抽象部分

```c++
class AbstractShip
{
public:
	AbstractShip(AbstractTeam* team) : m_team(team) {}
	void showTeam()
	{
		m_team->showMember();
		m_team->executeTask();
	}
	virtual string getName() = 0;
	virtual void feature() = 0;
private:
	AbstractTeam* m_team;
};

class Merry : public AbstractShip
{
public:
	using AbstractShip::AbstractShip;
	string getName() override
	{
		return "前进 · 梅丽号";
	}

	void feature() override
	{
		cout << getName() << " -- 船首为羊头, 在司法岛化身船精灵舍己救下了草帽一伙！" << endl;
	}
	
};

class HaiJunShip : public AbstractShip
{
public:
	using AbstractShip::AbstractShip;
	string getName() override
	{
		return string("无敌海军号");
	}
	void feature() override
	{
		cout << getName() << " -- 船底由海楼石建造, 可以穿过无风带的巨大炮舰!" << endl;
	}
};
```



03 测试程序

```c++
// 创建出一个草帽集团
AbstractTeam* caomao = new CaoMaoTeam("草帽海贼团");
Person* luffy = new Person("路飞", "船长", "橡胶果实能力者", "30亿贝里", "爱吃肉");
Person* zoro = new Person("索隆", "剑士", "三刀流", "11亿1100万贝里", "路痴");
Person* sanji = new Person("山治", "厨师", "隐形黑", "10亿3200万贝里", "好色");
Person* nami = new Person("娜美", "航海士", "天候棒+宙斯", "3亿6600万贝里", "喜欢钱");
caomao->addMember(luffy);
caomao->addMember(zoro);
caomao->addMember(sanji);
caomao->addMember(nami);

// 创建merry船，将草帽集团聚合其中
AbstractShip* ship = new Merry(caomao);
ship->feature();
ship->showTeam();

delete caomao;
delete ship;
```



## 4.3 组合模式

组合模式：<strong style="color:red">将多个对象组成一个树状结构，用于描述部分 —— 整体的层次关系，使得用户对单个对象和组合对象的使用具有一致性</strong>

组合模式类似的应用场景：

- Linux 的树状目录结构
- 国家的行政区划分（省级、地级、县级、乡级）
- 解放军编制（军、师、旅、团、营、连、排、班）
- 公司的组织结构（树状）

**示例**：为了让路飞成为海贼王，请使用组合模式为路飞写一个管理草帽大船团的程序，其对应的主要操作是这样的：==扩充船员==、==战斗减员==、==显示各船队信息==、==加入战斗==等。

**代码实现**

01 定义抽象船队

```c++
class AbstractTeam
{
public:
	AbstractTeam(string name) : m_name(name) {}
	// 设置父节点
	void setParent(AbstractTeam* node)
	{
		m_parent = node;
	}
	// 获取团队名
	string getName()
	{
		return m_name;
	}
	// 判断是否有孩子节点，默认返回 false(也就是说叶子节点不用单独设置)
	virtual bool hasChild()
	{
		return false;
	}
	// 添加孩子节点(这里不将其定义为纯虚函数的原因就是叶子节点是需要add的，若定义成纯虚函数，那么叶子节点也要重写)
	virtual void addChild(AbstractTeam* node) {}
	// 和 addChild 同理
	virtual void removeChild(AbstractTeam* node) {}

	// 战斗操作
	virtual void fight() = 0;
	// 显示战船信息
	virtual void display() = 0;

	~AbstractTeam() {}
protected:
	string m_name;
	AbstractTeam* m_parent = nullptr;
};
```

02 设置好叶子层和管理层

```c++
// 叶子节点
class LeafTeam : public AbstractTeam
{
public:
	using AbstractTeam::AbstractTeam;

	void fight()
	{
		cout << m_parent->getName() << "带领" << m_name << "与黑胡子的船员进行近距离肉搏..." << endl;
	}

	void display()
	{
		cout << "我是" << m_parent->getName() << "下属的" << m_name << endl;
	}
	~LeafTeam()
	{
		cout << "我是" << m_parent->getName() << "下属的" << m_name << "，我牺牲了..." << endl;
	}
};

// 管理层节点
class ManagerTeam : public AbstractTeam
{
public:
	using AbstractTeam::AbstractTeam;
	bool hasChild()
	{
		return true;
	}
	void addChild(AbstractTeam* node)
	{
		node->setParent(this);
		m_child.push_back(node);
	}
	void removeChild(AbstractTeam* node)
	{
		node->setParent(nullptr);
		m_child.remove(node);
	}
	list<AbstractTeam*> getChild()
	{
		return m_child;
	}
	void fight()
	{
		cout << m_name << "和恶魔果实能力者战斗" << endl;
	}
	void display()
	{
		string info = "我们是" + m_name + "集团, 成员有: 【";
		for (const auto& i : m_child)
		{
			if (i == m_child.back())
			{
				info += i->getName() + "】";
			}
			else
			{
				info += i->getName() + ", ";
			}
		}
		cout << info << endl;
	}
private:
	list<AbstractTeam*> m_child;
};
```



03 定义测试程序并在测试完成后释放内存

```c++
void gameover(AbstractTeam* root)
{
	if (root == nullptr)
	{
		return;
	}
	if (root && root->hasChild())
	{
		// dynamic_cast 主要用于类层次间（继承关系）的上行和下行的转换，还可以用于类之间的 交叉转换
		list<AbstractTeam*> children = dynamic_cast<ManagerTeam*>(root)->getChild();
		for (const auto& i : children)
		{
			gameover(i);
		}
	}
	delete root;
}

void fighting()
{
	AbstractTeam* root = new ManagerTeam("草帽大贼团");
	vector<string> nameList = {
		"俊美海贼团", "巴托俱乐部", "八宝水军", "艾迪欧海贼团",
		"咚塔塔海贼团", "巨兵海贼团", "约塔玛利亚大船团"
	};

	for (const auto& i : nameList)
	{
		// 将所有的贼团都加入都草帽麾下
		AbstractTeam* node = new ManagerTeam(i);
		root->addChild(node);
		// 这里仅演示巨兵海贼团
		if (i == "巨兵海贼团")
		{
			for (int i = 1; i <= 5; ++i)
			{
				AbstractTeam* leaf = new LeafTeam("第" + to_string(i) + "番队");
				// 利用 string 库中的 to_string() 函数将 int 转换为 string
				node->addChild(leaf);
				leaf->fight();
				leaf->display();
			}
		}
		node->fight();
		node->display();
	}
	root->fight();
	root->display();

	cout << "==================战斗结束==================" << endl;
	gameover(root);
}
```



## 4.4 装饰模式

装饰模式：<strong style="color:red">也称为封装模式，即在原有行为之上加以拓展，不改变原来的行为。</strong>

我们结合已有知识或日常生活，与之相关的就有：

- OSI 七层模型，下层对上层逐层封装，然后在物理层全部转换为比特流传输到另一端
- 练级游戏中，主角开始都是 "赤裸裸"，需要考后期不断打怪升级来获得新的装备

示例：在海贼王世界，人自身拥有一定的战斗能力，通过恶魔果实能够进行 "附魔" 获得额外的能力

**代码实现**

01 将战士基类定好

```c++
class Soldier
{
public:
	Soldier() {}
	Soldier(string name) : m_name(name) {}

	string getName()
	{
		return m_name;
	}
	virtual void fight() = 0;
	virtual ~Soldier() {}
protected:
	string m_name = string();
};
```



02 黑胡子

```c++
class Teach : public Soldier
{
public:
	using Soldier::Soldier;
	void fight() override
	{
		cout << "黑胡子自身拥有超强的格斗能力..." << endl;
	}
};
```



03 恶魔果实以及他的派生类

这里要进行附魔操作，在原先的基础上加以扩展

```c++
// 这里需要注意的是：让恶魔果实继承战士其实只是让其添加一层外衣
class DevilFruit : public Soldier
{
public:
	// 添加附魔操作
	void enchantment(Soldier* human)
	{
		m_human = human;
		m_name = human->getName();
	}

	virtual ~DevilFruit() {}
protected:
	// 包裹体
	Soldier* m_human = nullptr;

};

// 暗暗果实
class DarkFruit : public DevilFruit
{
public:
	void fight() override
	{
		m_human->fight();	// 将包裹体的fight()方法调用
		cout << "获得暗暗果实的能力，拥有了黑洞一样的吞噬万物的能力..." << endl;
		warning();
	}
private:
	void warning()
	{
		cout << m_name << ", 你要注意: 吃了暗暗果实, 身体元素化之后不能躲避攻击，会吸收所有伤害!" << endl;
	}
};

//  震震果实
class QuakeFruit : public DevilFruit
{
	void fight() override
	{
		m_human->fight();
		cout << "获得震震果实的能力，拥有了震动大地的能力..." << endl;
	}
};

// 大饼果实
class PieFruit : public DevilFruit
{
public:
	void fight() override
	{
		m_human->fight();
		cout << "获得大饼果实的能力，能够获得坚不可摧的铠甲..." << endl;
		ability();
	}

private:
	void ability()
	{
		cout << m_name << ", 恭喜您: 吃了大饼果实, 您可以不断给队友回复血量" << endl;
	}
};
```



04 测试程序

```c++
// 创造【黑胡子】
Soldier* teach = new Teach("黑胡子");
// 创造【暗暗果实】
DevilFruit* darkFruit = new DarkFruit();
// 创造【震震果实】
DevilFruit* quakeFruit = new QuakeFruit();
// 创造【大饼果实】
DevilFruit* pieFruit = new PieFruit();
// 使用暗暗果实给黑胡子附魔
darkFruit->enchantment(teach);
// 使用震震果实给黑胡子附魔
quakeFruit->enchantment(darkFruit);
// 使用大饼果实给黑胡子附魔
pieFruit->enchantment(quakeFruit);

// 究极大胡子开始战斗
pieFruit->fight();
```



## 4.5 外观模式

外观模式：就是将需要复杂的子系统封装（或者集成）到一起，然后向外暴露（或者提供）向上的接口供客户使用，客户不需要关注内部的逻辑实现，只需要直接通过相对应的命令或API调用即可。

实际场景：

- 电商平台
  - 上层接口：用于下单、查看物流信息、确认收货的用户界面
  - 底层模块：供货商、仓库、包装、送货、支付处理、售后等

示例：模拟 "狮吼炮"

01 装载子系统

```c++
// 可乐系统: 提供可乐能量
class CokeSystem
{
public:
	void injectEnergy()
	{
		cout << "可乐能量补给完毕，开始准备注射" << endl;
	}
};
// 能量转换系统
class EnergyConvertSystem
{
public:
	// 启动能量转换系统
	void init()
	{
		cout << "能量转换系统启动，开始转换" << endl;
	}
};
// 目标锁定系统
class TargetLockSystem
{
public:
	void lock()
	{
		cout << "目标锁定系统启动，开始锁定" << endl;
	}
};
// 加农炮发射系统
class CannonSystem
{
public:
	void cannonFire()
	{
		cout << "加农炮正在向目标开火..." << endl;
	}
};
// 风来炮稳定系统
class WindCannon
{
public:
	void windCannonFire()
	{
		cout << "发射风来炮抵消后坐力稳定船身..." << endl;
	}
};
```



02 集成环境（提供上层接口）

```c++
class LionCannon
{
public:
	LionCannon()
	{
		cokeSystem = new CokeSystem();
		energyConvertSystem = new EnergyConvertSystem();
		targetLockSystem = new TargetLockSystem();
		cannonSystem = new CannonSystem();
		windCannon = new WindCannon();
	}
	~LionCannon()
	{
		delete cokeSystem;
		delete energyConvertSystem;
		delete targetLockSystem;
		delete cannonSystem;
		delete windCannon;
	}
	// 准备工作：装载能量 -> 转换能量 -> 锁定目标
	void ready()
	{
		cokeSystem->injectEnergy();
		energyConvertSystem->init();
		targetLockSystem->lock();
	}

	// 发射炮弹
	void fire()
	{
		cannonSystem->cannonFire();
		windCannon->windCannonFire();
	}
private:
	CokeSystem* cokeSystem = nullptr;
	EnergyConvertSystem* energyConvertSystem = nullptr;
	TargetLockSystem* targetLockSystem = nullptr;
	CannonSystem* cannonSystem = nullptr;
	WindCannon* windCannon = nullptr;
};
```



**类图**

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230515112340640.png" alt="image-20230515112340640" style="zoom:50%;" />



## 4.6 享元模式（flyweight）

享元模式：就是**摒弃在每个对象中都保存所有的数据**这种方式，通过数据共享（缓存）让有限的内存可以加载更多的对象

享元模式的应用十分广泛，最常见的例如：

- 模块化、组件化编程
- 高速缓存
- 线程池

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/flyweight-zh.png" alt="享元设计模式" style="zoom: 50%;" />

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/components.png" alt="Component Tree" style="zoom:50%;" />

> 在享元模式中，我们有两个概念：
>
> - 内在状态：静态资源、复用模块
> - 外在状态：动态属性、自定义模块
>
> > 我们一般将内在状态单独放在一个类中，这种类我们称之为享元类

示例：游戏炸弹模拟，将组成资源划分，我们可以划分为如下资源：

- 静态资源：==精灵图==、==渲染颜色==
- 动态属性：==坐标==、==速度==

**代码实现**

01 设计享元

```c++
// 享元类的基类
class FlyWeightBody
{
public:
	FlyWeightBody(string sprite) : m_sprite(sprite) {}
	virtual void move(int x, int y, int speed) = 0;
	virtual void draw(int x, int y) = 0;
	virtual ~FlyWeightBody() {}
protected:
	string m_sprite;
	string m_color = string("black");
};

// 享元类的子类 —— 炮弹（该类作为共享炸弹体）
class SharedBombBody : public FlyWeightBody
{
public:
	using FlyWeightBody::FlyWeightBody;
	void move(int x, int y, int speed) override
	{
		cout << "炸弹以每小时" << speed << "公里的速度向" << x << "," << y << "移动" << endl;
	}
	void draw(int x, int y) override
	{
		cout << "在(" << x << ", " << y << ")处重新绘制炸弹" << endl;
	}
};

// 享元类的子类 —— 特殊彩蛋
class UniqueBombBody : public FlyWeightBody
{
public:
	using FlyWeightBody::FlyWeightBody;
	void move(int x, int y, int speed) override
	{
		cout << "彩蛋以每小时" << speed << "公里的速度向" << x << "," << y << "发放奖励" << endl;
	}
	void draw(int x, int y) override
	{
		cout << "在(" << x << ", " << y << ")处绘制彩蛋" << endl;
	}
};
```



02 设计炸弹（以 享元部分——弹体 为部分）

```c++
// 设计炸弹(炸弹的弹体为静态，为享元部分)
class LaunchBomb
{
public:
	LaunchBomb(FlyWeightBody* body) : m_body(body) {}
	int getX()
	{
		return m_x;
	}
	int getY()
	{
		return m_y;
	}
	void setSpeed(int speed)
	{
		m_speed = speed;
	}
	int getSpeed()
	{
		return m_speed;
	}
	void move(int x, int y)
	{
		m_x = x;
		m_y = y;
		m_body->move(x, y, m_speed);
		// 当炸弹移动后需要重新绘制
		draw();
	}
	void draw()
	{
		m_body->draw(m_x, m_y);
	}
private:
	// 动态参数信息
	int m_x = 0;
	int m_y = 0;
	int m_speed = 100;
	// 利用多态将炸弹体聚合其中
	FlyWeightBody* m_body = nullptr;
};
```



03 设计炸弹工厂（炸弹池）

```c++
class BombFactory
{
public:
	// 获取炸弹实例,这里的 name 对应的就是炸弹的精灵图
	FlyWeightBody* getBomb(string name)
	{
		auto it = m_bombPool.find(name);
		if (it != m_bombPool.end())
		{
			cout << name << "已存在于炸弹工厂中，正在复用" << name << "炸弹" << endl;
			return it->second;
		}
		else
		{
			FlyWeightBody* t = new SharedBombBody(name);
			m_bombPool.insert(make_pair(name, t));
			cout << name << "在炸弹工厂中不存在，正在创建" << name << "炸弹" << endl;
			return t;
		}
	}

	~BombFactory()
	{
		for (auto i : m_bombPool)
		{
			delete i.second;
		}
	}
private:
	map<string, FlyWeightBody*> m_bombPool;
};
```



04 测试程序

```c++
BombFactory* factory = new BombFactory;
vector<string> nameList = { "撒旦-1", "撒旦-2", "撒旦-3", "撒旦-4", "撒旦-5", "撒旦-2", "撒旦-1", "撒旦-8" };
vector<LaunchBomb*> bombList;	// 存储创建出来的炸弹，并在使用完成之后将其销毁
for (auto i : nameList)
{
    int x = 0, y = 0;
    LaunchBomb* bomb = new LaunchBomb(factory->getBomb(i));
    bombList.push_back(bomb);
    // 随机移动三次
    for (int i = 0; i < 3; ++i)
    {
        x += rand() % 100;
        y += rand() % 100;
        bomb->move(x, y);
    }
    cout << "========================" << endl;
}

// 测试彩蛋
UniqueBombBody* unique = new UniqueBombBody("彩蛋");
LaunchBomb* uniqueBomb = new LaunchBomb(unique);
bombList.push_back(uniqueBomb);
int x = 0, y = 0;
for (int i = 0; i < 3; ++i)
{
    x += rand() % 100;
    y += rand() % 100;
    uniqueBomb->move(x, y);
}
cout << "========================" << endl;

for (auto i : bombList)
{
    delete i;
}
```



**类图**



## 4.7 代理模式

代理模式：为其他对象提供一种代理，以控制对这个对象的访问。

结合日常的生活场景：

1. 使用微信、支付宝、信用卡等支付方式替代现金支付
2. 通过 VPN 访问外网

**示例：代理人进行交流通话**

01 设置代理基础（即抽象通信类）

```c++
class Commuication
{
public:
	virtual void commuicate() = 0;
	virtual ~Commuication() {}
};
```



02 设置具体通信类和代理类

```c++
// 设置具体通信类
class Speaker : public Commuication
{
public:
	void commuicate() override
	{
		cout << "我是本体，我正在通信交流..." << endl;
	}
};

// 设置代理类
class Proxy : public Commuication
{
public:
	Proxy(bool isAuth, Commuication* speaker) : isAuth(isAuth), speaker(speaker) {}

	void commuicate() override
	{
		if (isAuth)
		{
			cout << "=====================" << endl;
			cout << "我是代理对象，接下来我将代理speaker进行通话:..." << endl;
			speaker->commuicate();
			cout << "代理通话结束..." << endl;
			cout << "=====================" << endl;

		}
		else
		{
			cout << "我是代理对象，但是我没有得到授权，无法代理speaker进行通话..." << endl;
		}
	}

	void setAuth(bool isAuth)
	{
		if (isAuth) cout << "代理开启..." << endl;
		else cout << "代理关闭..." << endl;
		this->isAuth = isAuth;
	}

	~Proxy()
	{
		if (speaker != nullptr) delete speaker;
	}
private:
	Commuication* speaker;	// 被代理对象
	bool isAuth;	// 是否得到代理授权
};
```



03 测试程序

```c++
// 直接通信
Commuication* speaker = new Speaker;
speaker->commuicate();

// 代理通信
Commuication* proxySpeaker = new Proxy(true, speaker);
proxySpeaker->commuicate();
```



**类图**

<img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/image-20230515220429463.png" alt="image-20230515220429463" style="zoom:50%;" />



# 5 行为模式

## 5.1 责任链模式

责任链模式：即将对象按某种次序（例如等级）连成一条链，并沿着这条链传递请求，直到链上有一个对象将其处理掉为止。

> 责任链模式可以让处理者决定不再沿着链传递请求，这样可以高效地取消后续所有处理步骤

![处理者依次排列，组成一条链](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/solution1-zh.png)

责任链模式中会将具有特定行为转换的对象称为 ==处理者==

结合我们日常生活，责任链模式的应用场景有：

- 公司的 OA 审批系统

- GUI 操作界面

  <img src="https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/solution2-zh.png" alt="对象树的枝干可以组成一条链" style="zoom:50%;" />

我们以公司的审批制度为例，编写一个简单的责任链：<u>底层管理者 -> CEO -> BOSS</u>

**01 管理者的抽象类**

```c++
class AbstractManager
{
public:
	// 请求方法
	virtual void handleRequest(RequestType type) = 0;
	// 设置上级管理层
	void setNext(AbstractManager* manager) {
		m_next = manager;
	}
	virtual ~AbstractManager() {}
protected:
	AbstractManager* m_next = nullptr;		// 上层管理者
};
```



**请求类型**

```c++
enum class RequestType : char
{
	qingjia,			// 请假
	zhangxin,			// 涨薪
	cizhi				// 辞职
};
```



**02 管理层**

```c++
// 底层管理者
class Manager : public AbstractManager
{
	void handleRequest(RequestType type)
	{
		switch (type)
		{
		case RequestType::qingjia:
			cout << "你最近表现不错，同意批假，注意身体..." << endl;
			break;
		case RequestType::zhangxin:
			cout << "我只是一个小领导，没有权利批准你涨薪，我去请示上级..." << endl;
			m_next->handleRequest(type);
			break;
		case RequestType::cizhi:
			cout << "我只是一个小领导，没有权利批准你辞职，我去请示上级..." << endl;
			m_next->handleRequest(type);
			break;
		default:
			break;
		}
	}
};

// CEO
class CEO : public AbstractManager
{
	void handleRequest(RequestType type)
	{
		switch (type)
		{
		case RequestType::qingjia:
			cout << "天天007，辛苦了，给你放半天..." << endl;
			break;
		case RequestType::zhangxin:
			cout << "涨薪？涨个p..." << endl;
			break;
		case RequestType::cizhi:
			cout << "辞职干系重大，我作为公司CEO，得去请示BOSS..." << endl;
			m_next->handleRequest(type);
			break;
		default:
			break;
		}
	}
};

// BOSS
class BOSS : public AbstractManager
{
	void handleRequest(RequestType type)
	{
		switch (type)
		{
		case RequestType::qingjia:
			cout << "在公司不就是放假吗？小伙子要把公司当做自己家..." << endl;
			break;
		case RequestType::zhangxin:
			cout << "公司最近发展势头正猛，需要大量资金，得过段时间再说..." << endl;
			break;
		case RequestType::cizhi:
			cout << "最近工作不好找，奉劝你再想想，要不要给你加点钱就算了.." << endl;
			break;
		default:
			break;
		}
	}
};
```



**03 打工人（客户端）**

```c++
class DaCongMing
{
public:
	// 发起请求，请求包含两个参数：请求类型和请求对象
	void request(RequestType type, AbstractManager* manager)
	{
		manager->handleRequest(type);
	}
};
```



**04 测试程序**

```c++
// 测试程序
DaCongMing* daCongMing = new DaCongMing;
// 分别创建好 manager、CEO 和 BOSS, 并且设置其上下级关系
AbstractManager* manager = new Manager;
AbstractManager* ceo = new CEO;
AbstractManager* boss = new BOSS;
ceo->setNext(boss);
manager->setNext(ceo);

// 大聪明开始分别向三层上级请求
cout << "==============大聪明向底层管理层发送请求==============" << endl;
daCongMing->request(RequestType::qingjia, manager);
daCongMing->request(RequestType::zhangxin, manager);
daCongMing->request(RequestType::cizhi, manager);

cout << "==============大聪明越级向CEO发送请求==============" << endl;
daCongMing->request(RequestType::qingjia, ceo);
daCongMing->request(RequestType::zhangxin, ceo);
daCongMing->request(RequestType::cizhi, ceo);

cout << "==============大聪明越级向BOSS发送请求==============" << endl;
daCongMing->request(RequestType::qingjia, boss);
daCongMing->request(RequestType::zhangxin, boss);
daCongMing->request(RequestType::cizhi, boss);

delete daCongMing;
delete manager;
delete ceo;
delete boss;
```



总结：示例是一种比较简单情况下的责任链模式，即节点与节点之间为单向链表形式，但是还存在一些比较复杂的情况，例如节点之间关系可能为双向链表（较少）、树、图等



## 5.2 命令模式

命令模式：官方做出的解释为，**将一个请求封装为一个对象，从而使你可用不同的请求<u>对客户进行参数化</u>，对请求排队或记录请求日志，以及支持可撤销的操作。**

在日常生活中，点餐就是一个很好的命令模式的应用场景：厨师作为命令的执行者，服务员/客户作为命令的调用者，在点餐过程中，可以有如下需求：

1. 客户可以点多个菜，待客户点菜完毕后，服务器将点餐表交给厨师，厨师根据点餐表来做菜
2. 根据点餐列表来结账
3. 顾客可以取消已下单但没有开始制作的菜

![command-comic-1](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/command-comic-1.png)



**01 执行者：厨师类**

```c++
class Cooker
{
public:
	void makeDSK()
	{
		cout << "烹饪地三鲜..." << endl;
	}

	void makeGBJD()
	{
		cout << "烹饪宫保鸡丁" << endl;
	}

	void makeYXRS()
	{
		cout << "烹饪鱼香肉丝" << endl;
	}

	void makeHSPG()
	{
		cout << "烹饪红烧排骨" << endl;
	}
};
```



**02 命令集群**

```c++
// 命令类--抽象类
class AbstractCommand
{
public:
	AbstractCommand(Cooker* cooker) : m_cooker(cooker) {}
	virtual void excute() = 0;
	virtual string getName() = 0;
protected:
	Cooker* m_cooker = nullptr;
};

// 具体命令1: 烹饪地三鲜
class DSXCommand : public AbstractCommand
{
public:
	using AbstractCommand::AbstractCommand;
	void excute() override
	{
		m_cooker->makeDSK();
	}

	string getName() override
	{
		return "地三鲜";
	}
};

// 具体命令2：烹饪宫保鸡丁
class GBJDCommand : public AbstractCommand
{
public:
	using AbstractCommand::AbstractCommand;
	void excute() override
	{
		m_cooker->makeGBJD();
	}

	string getName() override
	{
		return "宫保鸡丁";
	}
};

// 具体命令3：烹饪鱼香肉丝
class YXRSCommand : public AbstractCommand
{
public:
	using AbstractCommand::AbstractCommand;
	void excute() override
	{
		m_cooker->makeYXRS();
	}

	string getName() override
	{
		return "鱼香肉丝";
	}
};

// 具体命令4：烹饪红烧排骨
class HSPGCommand : public AbstractCommand
{
public:
	using AbstractCommand::AbstractCommand;
	void excute() override
	{
		m_cooker->makeHSPG();
	}

	string getName() override
	{
		return "红烧排骨";
	}
};
```



**03 调用者**

```c++
// 调用命令类：顾客 / 服务员
class Waiter
{
public:
	// 下单
	void placeOrder(int index, AbstractCommand* command)
	{
		cout << "第" << index << "号桌顾客点了一份" << command->getName() << endl;
		// 此处做一个截断，现在没有鱼，做不了鱼香肉丝
		if (command->getName() == "鱼香肉丝")
		{
			cout << "抱歉，现在没有鱼了，无法做鱼香肉丝..." << endl;
			return;
		}
		// 当该桌顾客之前没有点过餐，那么我们需要新建一份 order
		if (m_order.find(index) == m_order.end())
		{
			list<AbstractCommand*> t{ command };
			m_order.insert(make_pair(index, t));
		}
		else
		{
			m_order[index].push_back(command);
		}
	}

	// 取消订单
	void cancelOrder(int index, AbstractCommand* command)
	{
		if (m_order.find(index) != m_order.end())
		{
			m_order[index].remove(command);	// 这样写的可行性？？？
			// 由于这里的命令都是复用的，所以可以直接通过 remove 方法移除
			cout << "第" << index << "号桌顾客取消了" << command->getName() << endl;
		}
		else
		{
			cout << "目前还没有该号桌顾客的订单，请再次确认是否有误" << endl;
		}
	}

	// 结账
	void checkout(int index)
	{
		cout << "第" << index << "号桌顾客点的餐包括：【";
		if (m_order.find(index) != m_order.end())
		{
			list<AbstractCommand*> t = m_order.at(index);
			for (const auto& item : t)
			{
				if (item != t.back())
				{
					cout << item->getName() << ", ";
				}
				else
				{
					cout << item->getName() << "】" << endl;
				}
			}
		}
		// 在结账过后，我们还需要做一步操作就是将该桌状态重置
		if (m_order.erase(index))
		{
			cout << "第" << index << "号桌顾客结账完毕，正在清理..." << endl;
		}
	}

	// 给厨师递交订单
	void notify(int index)
	{
		cout << "==================厨师正在为第" << index << "号桌烹饪==================" << endl;
		for (const auto& item : m_order[index])
		{
			item->excute();
		}
		cout << "==================烹饪结束==================" << endl;
	}
private:
	// 订单：key 为订单号，value 为订单列表
	map<int, list<AbstractCommand*>> m_order;

};
```



**04 测试程序**

```c++
// 准备好厨师长
Cooker* cooker = new Cooker;
// 准备服务员
Waiter* waiter = new Waiter;

// 建立炒菜命令
AbstractCommand* dsx = new DSXCommand(cooker);
AbstractCommand* gbjd = new GBJDCommand(cooker);
AbstractCommand* yxrs = new YXRSCommand(cooker);
AbstractCommand* hspg = new HSPGCommand(cooker);

// 1 号桌点菜
waiter->placeOrder(1, dsx);
waiter->placeOrder(1, gbjd);
waiter->placeOrder(1, yxrs);
waiter->placeOrder(1, hspg);

// 2 号桌上菜
waiter->placeOrder(2, dsx);
waiter->placeOrder(2, gbjd);
waiter->placeOrder(2, yxrs);
waiter->placeOrder(2, hspg);

// 1 号桌撤销了鱼香肉丝
waiter->cancelOrder(1, yxrs);

// 2 号桌撤销了红烧排骨
waiter->cancelOrder(2, hspg);

// 服务员处理1号桌
waiter->notify(1);
waiter->checkout(1);

// 服务员处理2号桌
waiter->notify(2);
waiter->checkout(2);


delete cooker;
delete waiter;
delete dsx;
delete gbjd;
delete yxrs;
delete hspg;
```



命令模式最大的特点：松耦合设计，具有以下优势：

1. 可以很容易设计出一个==命令队列==
2. 可以很容易将命令==记录日志==中
3. 允许接收请求的一方是否决定要==否决请求==
4. 可以很容易实现对请求的==撤销和重置==



## 5.3 迭代器模式

迭代器模式：即提供一种解决方案使得我们能够顺序访问一个集合对象中的各个元素，而又不暴露该集合底层的表现形式（列表、栈、树、图等）

> 我们可以举个例子，我们如果想要树或图，可以采用 ==DFS== 和 ==BFS==，但是如果我们现在只是想要遍历一个简单的数组呢？是不是就行不通了，所以这时最好的解决方式就是==将集合与它对应的遍历算法解耦==

迭代器应用十分广泛，但是我们在大多时候是不要自己亲自手动实现的，因为各种编程语言底层已经替我们实现了，例如：

- C++ 中的 iterator 
- Java 中的 Iterator

迭代器其实就是为我们提供一种遍历方式，我们下面手动实现一个迭代器类来完成集合对象的遍历

**01 定义集合和链表**

<u>**MyList.h**</u>

```c++
#pragma once		// 避免同一个头文件被包含多次，另一种方式是使用 #inndef …… #endif
#include <string>
using namespace std;

// 类声明
class Iterator;
// 定义节点
struct Node
{
	Node(string d) : data(d) {}
	string data = string();
	Node* next = nullptr;
	Node* prev = nullptr;
};

// 定义双向链表
class MyList
{
public:
	// 对经常操作且函数体内无复杂结构（例如循环）的函数使用 inline 将其转换为内联函数
	// 本质直接将程序替换，是一种以空间换时间的做法
	inline int getLen()
	{
		return m_len;
	}

	inline Node* getHead()
	{
		return m_head;
	}

	inline Node* getTail()
	{
		return m_tail;
	}
	// 在头文件中对复杂函数只声明，定义在源文件中实现
	Node* insert(Node* item, string data);	// 返回值为插入的节点
	Node* pushFront(string data);
	Node* pushBack(string data);
	Iterator* getIterator(bool isReverse = false);
private:
	Node* m_head = nullptr;
	Node* m_tail = nullptr;
	int m_len = 0;
};
```



<u>**MyList.cpp**</u>

```c++
#include "MyList.h"
#include "iterator.h"

Node* MyList::insert(Node* item, string data)
{
	if (item == m_head)
	{
		return pushFront(data);
	}
	else
	{
		Node* node = new Node(data);
		item->prev->next = node;
		node->prev = item->prev;

		node->next = item;
		// 这里需要注意的是：需要我们将 item->prev 放在最后，否则我们无法根据 item 得到其前驱
		item->prev = node;
		m_len++;
	}
}

Node* MyList::pushFront(string data)
{
	Node* node = new Node(data);
	if (m_head == nullptr)
	{
		m_head = m_tail = node;
	}
	else
	{
		node->next = m_head;
		m_head->prev = node;
		m_head = node;
	}

	m_len++;
	return node;
}

Node* MyList::pushBack(string data)
{
	Node* node = new Node(data);
	if (m_tail == nullptr)
	{
		m_tail = m_head = node;
	}
	else
	{
		m_tail->next = node;
		node->prev = m_tail;
		m_tail = node;
	}
	m_len++;
	return node;
}

Iterator* MyList::getIterator(bool isReverse)
{
	if (isReverse)
	{
		return new ReverseIterator(this);
	}
	else
	{
		return new ForwardIterator(this);
	}
}
```



**02 定义迭代器**

<u>**Iterator.h**</u>

```c++
#pragma once
#include "MyList.h"
// 定义抽象的迭代器类 
class Iterator
{
public:
	Iterator(MyList* list) : m_list(list) {}
	Node* getCurrent()	// 用于得到当前指针所指向的节点
	{
		return m_current;
	}
	virtual Node* next() = 0;	// 指向下一个接待，如果是正向遍历，那么 next 会使得 m_current 指向双向链表下一个节点，反之则反
	virtual Node* first() = 0;	// 得到遍历的首节点，如果是正向遍历，那么 first 返回的就是 m_head,反之则是 m_tail
	virtual bool isDone() = 0;
	virtual ~Iterator() {}
protected:
	MyList* m_list = nullptr;
	Node* m_current = nullptr;
};

// 正向迭代器
class ForwardIterator : public Iterator
{
public:
	using Iterator::Iterator;
	Node* next() override
	{
		m_current = m_current->next;
		return m_current;
	}

	Node* first() override
	{
		m_current = m_list->getHead();
		return m_current;
	}

	bool isDone() override
	{
		return m_list->getTail()->next == m_current;
		// return m_current = nullptr
	}
};

// 逆向迭代器
class ReverseIterator : public Iterator
{
public:
	using Iterator::Iterator;
	Node* next() override
	{
		m_current = m_current->prev;
		return m_current;
	}

	Node* first() override
	{
		m_current = m_list->getTail();
		return m_current;

	}

	bool isDone() override
	{
		return m_list->getHead()->prev == m_current;
		// return m_current == nullptr;
	}
};
```



<u>**iterator.cpp**</u>

```c++
#include <iostream>
#include <vector>
#include "Iterator.h"
#include "MyList.h"

int main()
{
	vector<string> nameList{
		"烬", "奎因", "杰克", "福兹·弗", "X·德雷克",
		"黑色玛利亚", "笹木", "润媞", "佩吉万",
		"一美", "二牙", "三鬼", "四鬼", "五鬼",
		"六鬼", "七鬼", "八茶", "九忍","十鬼"
	};

	MyList myList;
	for (const auto& item : nameList)
	{
		myList.pushBack(item);
	}

	// 正向遍历
	Iterator* it = myList.getIterator();
	for (auto begin = it->first(); !it->isDone(); it->next())	// 感觉这里实现有点假，和C++迭代器 有所区别
	{
		cout << it->getCurrent()->data << endl;
	}

	cout << "=============================" << endl;

	// 反向遍历
	Iterator* rt = myList.getIterator(true);
	for (auto begin = rt->first(); !rt->isDone(); rt->next())
	{
		cout << rt->getCurrent()->data << endl;
	}
	return 0;
}
```



## 5.4 中介者

中介者模式：用**一个中介对象来封装一系列的对象交互**，中介者使各对象不需要显示地相互引用，从而使其耦合松散，并且限制对象之间的直接交互，使得他们需要通过通过一个中介者对象进行合作

中介者模式在日常生活中的应用场景：

- 联合国
- 各种中介机构
- 十字路口的信号灯或交警

**示例**

```c++
// Country.h
#pragma once
#include <iostream>
#include <string>
class Mediator;
class Country
{
public:
	Country(Mediator* mediator) : m_mediator(mediator) {}
	/*
	 * msg: 发送的消息
	 * country: 发送方，即 from
	 * name: 接收方国家名
	 */
	virtual void declare(std::string msg, std::string name = std::string());
	virtual void receiveMsg(std::string msg);
	virtual std::string getName() = 0;

protected:
	Mediator* m_mediator;
};

class UK : public Country
{
public:
	using Country::Country;
	std::string getName() override;
};

class US : public Country
{
public:
	using Country::Country;
	std::string getName() override;

};

class CN : public Country
{
public:
	using Country::Country;
	std::string getName() override;

};

class RU : public Country
{
public:
	using Country::Country;
	std::string getName() override;
};
```



```c++
// Country.cpp
#include "Country.h"
#include "Mediator.h"

void Country::declare(std::string msg, std::string name)
{
	m_mediator->declare(msg, this, name);
}

void Country::receiveMsg(std::string msg)
{
	std::cout << this->getName() << "收到消息——" << msg << std::endl;
}

std::string UK::getName()
{
	return "英国";
}

std::string US::getName()
{
	return "美国";
}

std::string CN::getName()
{
	return "中国";
}

std::string RU::getName()
{
	return "俄罗斯";
}
```



```c++
// Mediator.h
#pragma once
#include <map>
#include <string>
// 该头文件中存放的内容包括中介者相关的类
class Country;
class Mediator
{
public:
	// 添加成员方法
	void addMember(Country* country);
	// 中介者（调停者）发声明，需要注意的是国家通过中介者来发声明
	// 由于不同组织的发声明方式不同（可能群发，也可能一对一发送），因此需要将其定义为纯虚函数
	virtual void declare(std::string msg, Country* country, std::string name) = 0;
	virtual ~Mediator() {}
protected:
	std::map<std::string, Country*> m_countryMap;
};

// 世界政府组织
class WorldOrg : public Mediator
{
public:
	void declare(std::string msg, Country* country, std::string name = std::string()) override;
};

// 革命军
class RevolutionOrg : public Mediator
{
public:
	void declare(std::string msg, Country* country, std::string name = std::string()) override;
};
```



```c++
// mediator.cpp
#include <iostream>
#include "Country.h"
#include "Mediator.h"

void Mediator::addMember(Country* country)
{
	m_countryMap.insert(std::make_pair(country->getName(), country));
}

void WorldOrg::declare(std::string msg, Country* country, std::string name)
{
	// 对于世界政府组织而言，一对一通信
	if (m_countryMap.find(name) != m_countryMap.end())
	{
		std::cout << "收到来自【" << country->getName() << "】的消息: ";
		m_countryMap.at(name)->receiveMsg(msg);
	}
}

void RevolutionOrg::declare(std::string msg, Country* country, std::string name)
{
	// 对于革命军而言,是广播,所以在革命军阵营，name 字段是没有用的，可以不传
	for (const auto& item : m_countryMap)
	{
		if (item.first == country->getName())
		{
			// 自己国不需要给自己国再发送声明，直接跳过
			continue;
		}
		else
		{
			std::cout << "收到来自【" << country->getName() << "】的消息: ";
			item.second->receiveMsg(msg);
		}
	}
}
```



``` c++
// 测试程序
#include "Country.h"
#include "Mediator.h"

int main()
{
	// 世界政府
	Mediator* worldOrg = new WorldOrg;
	Country* us = new US(worldOrg);	// us 进入世界政府阵营
	Country* uk = new UK(worldOrg);	// uk 加入世界政府阵营
	// 世界政府添加成员
	worldOrg->addMember(us);
	worldOrg->addMember(uk);
	// us 向 uk 发送通告
	us->declare("做我小弟吧", uk->getName());
	uk->declare("好的，大哥", us->getName());
	delete uk;

	std::cout << "=================================" << std::endl;
	// 革命军
	Mediator* revolution = new RevolutionOrg;
	Country* cn = new CN(revolution);
	Country* ru = new RU(revolution);
	uk = new UK(revolution);

	// 革命军添加成员
	revolution->addMember(cn);
	revolution->addMember(ru);
	revolution->addMember(uk);

	cn->declare("举起社会主义的旗帜");

	// 释放内存
	delete worldOrg;
	delete us;
	delete uk;
	delete revolution;
	delete cn;
	delete ru;
	return 0;
}
```



## 5.5 备忘录模式

备忘录模式：即在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存该状态，那么在需要的时候我们就可以将该对象恢复到原先保存的状态

应用场景：

- 游戏的进度存档

- 文本编辑器

  ![在编辑器中撤销操作](https://theblogimage.oss-cn-fuzhou.aliyuncs.com/imagefortypora/problem1-zh.png)

**示例：解构历史**

如果我们要记录历史，那么至少有三部分是必须的，分别是：

1. 历史的亲历者
2. 记录历史的载体
3. 记录者

这三部分对应备忘录模式中的三要素：==事件的主体==、==事件的内容==、==事件的记录者==，而如果对应我们打游戏，那么事件的主体对应玩家、事件内容对应存档、事件的记录者对应游戏程序。

> 在备忘录模式中，一个完整的流程应包含==存储（store）==与==加载（load）==的过程



**01 历史节点的载体**

```c++
class History
{
public:
	History(string msg) : m_msg(msg) {}
	string getHistory()
	{
		return m_msg;
	}
private:
	string m_msg;
};
```



**02 行为者**

```c++
class JiaoPenJi
{
public:
	// 设置状态信息
	void setState(string msg)
	{
		m_msg = msg;
	}

	// 得到状态信息
	string getState()
	{
		return m_msg;
	}

	// 保存历史节点
	History* setHistoryPoint()
	{
		return new History(m_msg);
	}

	// 加载历史节点
	void loadHistoryPoint(History* point)
	{
		m_msg = point->getHistory();
	}
private:
	// 当前犯下的罪行
	string m_msg;
};
```



**03 记录者**

```c++
class Recorder
{
public:
	void addHistoryPoint(History* history)
	{
		m_history.insert(make_pair(m_index, history));
		m_index++;
	}

	History* getHistoryPoint(int index)
	{
		return m_history[index];
	}
private:
	int m_index = 0;
	map<int, History*> m_history;
};
```



**04 测试程序**

```c++
JiaoPenJi* dirty = new JiaoPenJi;
Recorder* recorder = new Recorder;
vector<string> msg{
    "不承认偷了中国的中医!!!",
    "不承认发动了侵华战争!!!",
    "不承认南京大屠杀!!!!",
    "不承认琉球群岛和钓鱼岛是中国的领土!!!",
    "不承认731部队的细菌和人体试验!!!",
    "不承认对我国妇女做出畜生行为!!!",
    "不承认从中国掠夺的数以亿计的资源和数以万计的文物!!!",
    "我干的龌龊事儿罄竹难书, 就是不承认......"
};

for (const auto& item : msg)
{
    dirty->setState(item);
    recorder->addHistoryPoint(dirty->setHistoryPoint());
}

// 脚盆鸡当前的状态
cout << "脚盆鸡当前的状态为：" << dirty->getState() << endl;

// 回到 index 为 3 的历史节点状态
dirty->loadHistoryPoint(recorder->getHistoryPoint(3));
cout << "脚盆鸡在历史节点为3的状态为：" << dirty->getState() << endl;
```



## 5.6 观察者模式

观察者模式：也被称为 "发布 - 订阅" 模式，我们可以在对象事件发生时通知所有的观察者对象（订阅者），使他们能够自动更新。

观察者模式在日常生活和一些框架中也经常出现：

- 当我们在社交平台订阅了某些博主，当这些博主更新了一些新内容时，平台就会通知我们
- Vue 中的也存在这种 "发布-订阅" 机制，例如 emit - on

**示例**

```c++
// Observer.h
#pragma once
#include <string>
#include <vector>
class NewsAgency;
// 订阅者基类
class Observer
{
public:
	Observer(std::string name) : m_name(name) {}
	// 开始订阅
	void subscrible(NewsAgency* agency);
	// 取消订阅
	void unsubscrible(NewsAgency* agency);
	// 收到推送
	virtual void update(std::string msg) = 0;
	virtual ~Observer() {}
protected:
	std::string m_name;	// 订阅者姓名
	std::vector<NewsAgency*> m_subAgency;
};

class Alice : public Observer
{
public:
	using Observer::Observer;
	void update(std::string msg) override;
};

class Bob : public Observer
{
public:
	using Observer::Observer;
	void update(std::string msg) override;
};

class John : public Observer
{
public:
	using Observer::Observer;
	void update(std::string msg) override;
};

class Mike : public Observer
{
public:
	using Observer::Observer;
	void update(std::string msg) override;
};
```



```c++
// observer.cpp
#include <iostream>
#include "Observer.h"
#include "NewsAgency.h"
using namespace std;

void Alice::update(std::string msg)
{
	cout << "------Alice 收到来自该报社的信息：" << msg << endl;
}

void John::update(std::string msg)
{
	cout << "------John 收到来自该报社的信息：" << msg << endl;

}

void Mike::update(std::string msg)
{
	cout << "------Mike 收到来自该报社的信息：" << msg << endl;
}

void Bob::update(std::string msg)
{
	cout << "------Bob 收到来自该报社的信息：" << msg << endl;
}

void Observer::subscrible(NewsAgency* agency)
{
	for (auto it = m_subAgency.begin(); it != m_subAgency.end(); it++)
	{
		if (agency == *it) return;
	}
	agency->attach(this);
	m_subAgency.push_back(agency);
}

void Observer::unsubscrible(NewsAgency* agency)
{
	for (auto it = m_subAgency.begin(); it != m_subAgency.end(); it++)
	{
		if (agency == *it)
		{
			agency->deattach(this);
			m_subAgency.erase(it, it + 1);
			break;
		}
	}
}
```



```c++
// NewsAgency.h
#pragma once
#include <list>
#include <string>
//  该头文件中主要包含发布者相关的类定义（发布者在这里即为新闻社）
class Observer;	// 声明订阅者，只是做了声明，并没有包含该类
class NewsAgency
{
public:
	// 添加订阅者
	void attach(Observer* observer);
	// 删除订阅者
	void deattach(Observer* observer);
	// 发布报纸（由于不同报社的发报方式不同，因此在这里使用虚构函数）
	virtual void notify(std::string msg) = 0;
	virtual ~NewsAgency() {}
protected:
	// 需要注意的是 list 被放在 std 命令空间中，使用时需要添加命名空间
	std::list<Observer*> m_subscriber;
};

class Morgans : public NewsAgency
{
public:
	void notify(std::string msg) override;
};

class Gossip : public NewsAgency
{
public:
	void notify(std::string msg) override;
};
```



```c++
// newsAgency.cpp
#include "NewsAgency.h"
#include "Observer.h"
#include <iostream>

void NewsAgency::attach(Observer* observer)
{
	m_subscriber.push_back(observer);
}

void NewsAgency::deattach(Observer* observer)
{
	m_subscriber.remove(observer);
}

void Morgans::notify(std::string msg)
{
	std::cout << "摩根报社正在发送新报，当前订阅人数为：" << m_subscriber.size() << std::endl;
	for (const auto& item : m_subscriber)
	{
		item->update(msg);
	}

}

void Gossip::notify(std::string msg)
{
	std::cout << "八卦报社正在发送新报，当前订阅人数为：" << m_subscriber.size() << std::endl;
	for (const auto& item : m_subscriber)
	{
		item->update(msg);
	}
}
```



```c++
// 测试程序
#include "NewsAgency.h"
#include "Observer.h"

int main()
{
	// 创建摩根报社
	NewsAgency* morgans = new Morgans;
	// 创建八卦报社
	NewsAgency* gossip = new Gossip;
	// 创建观察者（订阅者）
	Observer* alice = new Alice("Alice");
	Observer* bob = new Bob("Bob");
	Observer* john = new John("John");
	Observer* mike = new Mike("Mike");

	// alice 订阅了摩根报社和八卦报社
	alice->subscrible(morgans);
	alice->subscrible(gossip);

	// bob、john、mike 订阅了摩根报社
	bob->subscrible(morgans);
	john->subscrible(morgans);
	mike->subscrible(morgans);

	// john 又订阅了八卦报社
	john->subscrible(gossip);

	// 摩根报社和八卦报社发文
	morgans->notify("某国今天突然与邻国开战，战况激烈");
	gossip->notify("某女明星今日与与一不知名男性在酒店门口");

	// john 厌恶八卦报社乱七八糟的新闻，准备退订
	john->unsubscrible(gossip);
	gossip->notify("八卦报社今天开始转型为专业报社");

	// 回收
	delete morgans;
	delete gossip;
	delete alice;
	delete bob;
	delete john;
	delete mike;
	return 0;
}
```



## 5.7 策略模式

策略模式：官方的解释为，通过定义一系列算法，并将其封装起来，使其可以<strong style="color:red">相互替换</strong>，算法的改变不会影响到使用算法的客户。

> 策略模式是一种行为模式，我们使用这种模式可以将处理逻辑分散到不同的类中，同时我们应将其与状态模式区分开，这两种模式十分相似，但是不同之处在于策略模式中每种策略之间是没有关联的

策略模式的应用场景：

- 结账时选择不同的支付方式，底层调用每种支付方式各自的 API
- 出行工具的选择，这也是一种策略，虽然选择的策略的不同，可以是飞机、轮船、火车，但最终目的地是相同的

**示例：结账**

**01 定义基础策略类和具体策略实现类**

```c++
class AbstractStrategy
{
public:
	virtual void payment(int num) = 0;
	virtual ~AbstractStrategy() {}
};

class WeChat : public AbstractStrategy
{
public:
	void payment(int num) override
	{
		cout << "使用微信支付了【" << num << "】元" << endl;
	}
};

class Alipay : public AbstractStrategy
{
public:
	void payment(int num) override
	{
		cout << "使用支付宝支付了【" << num << "】元" << endl;
	}
};

class Credit : public AbstractStrategy
{
public:
	void payment(int num) override
	{
		cout << "使用银行卡支付了【" << num << "】元" << endl;
	}
};
```



**02 定义使用主体**

```c++
class PayService
{
public:
	static void service(AbstractStrategy* strategy, int num);
};

void PayService::service(AbstractStrategy* strategy, int num)
{
	strategy->payment(num);
}
```



**03 测试程序**

```c++
PayService::service(new WeChat, 100);
PayService::service(new Alipay, 100);
PayService::service(new Credit, 100);
```



## 5.8 状态模式

状态模式：一个类的内部会有多种状态的变化，因为状态变化从而导致其行为的改变，在类的外部看上去这个类就像是自身发生的改变。

> 状态模式和策略模式十分类似，不同的是状态模式中不同的状态之间是有联系的，而策略模式中各策略之间是没有联系的

我们拿海贼王中的山治一天的状态的为例：

```c++
// State.h
#pragma once

class SanJi;

class AbstractState
{
public:
	virtual void working(SanJi* sanJi) = 0;
	virtual ~AbstractState() {}
};

class MorningState : public AbstractState
{
public:
	void working(SanJi* sanJi) override;
};

class NoonState : public AbstractState
{
public:
	void working(SanJi* sanJi) override;
};

class AfternoonState : public AbstractState
{
public:
	void working(SanJi* sanJi) override;
};

class EveningState : public AbstractState
{
public:
	void working(SanJi* sanJi) override;
};
```



```c++
// state.cpp
#include <iostream>
#include "State.h"
#include "SanJi.h"

void MorningState::working(SanJi* sanJi)
{
	// 得到当前的time -> 判断时间点 -> 切换状态
	int time = sanJi->getClock();
	if (time < 8)
	{
		std::cout << "当前时间是清晨，开始起床..." << std::endl;
	}
	else if (time >= 8 && time < 11)
	{
		std::cout << "当前时间是早上8-11点，需要准备食材" << std::endl;
	}
	else
	{
		// 由于时间顺延，所以这里会走到中午
		sanJi->setState(new NoonState);	// 将时间状态调整到中午
		sanJi->working();	// 注意这里的工作是实际上执行的是 m_state->working,也就是让 "状态来工作"
	}

}

void NoonState::working(SanJi* sanJi)
{
	int time = sanJi->getClock();

	if (time >= 11 && time < 13)
	{
		std::cout << "开始准备中饭..." << std::endl;
	}
	else
	{
		sanJi->setState(new AfternoonState);	// 将状态调整为下午
		sanJi->working();
	}
}

void AfternoonState::working(SanJi* sanJi)
{
	int time = sanJi->getClock();

	if (time >= 13 && time < 18)
	{
		std::cout << "下午时间到了，外出活动一下吧..." << std::endl;
	}
	else
	{
		sanJi->setState(new EveningState);
		sanJi->working();
	}
}

void EveningState::working(SanJi* sanJi)
{
	int time = sanJi->getClock();
	if (time >= 18 && time < 20)
	{
		std::cout << "开始准备晚餐..." << std::endl;
	}
	else
	{
		std::cout << "一天结束了，赶紧休息吧..." << std::endl;
	}
}
```



```c++
// Sanji.h
#pragma once

class AbstractState;

class SanJi
{
public:
	SanJi();
	int getClock();
	void setClock(int clock);
	void working();
	void setState(AbstractState* state);
private:
	int m_clock = 0;
	AbstractState* m_state = nullptr;
};
```



```c++
// sanJi.cpp
#include "SanJi.h"
#include "State.h"

SanJi::SanJi()
{
	// 在默认构造函数中将其初始化状态设置为早晨的状态
	m_state = new MorningState;
}

int SanJi::getClock()
{
	return m_clock;
}

void SanJi::setClock(int clock)
{
	m_clock = clock;
}

void SanJi::working()
{
	m_state->working(this);
}

void SanJi::setState(AbstractState* state)
{
	// 开始要切换状态
	if (m_state)
	{
		delete m_state;
		m_state = nullptr;
	}
	m_state = state;
}
```

> 其实感觉大丙来时这个例子用的不好，理想情况是能够像状态机那样灵活切换，这个例子的转态之间的切换过于生硬



## 5.9 模板方法模式

模板方法模式：在基类中定义一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。

> 模板方法模式是较为简单且易于理解的一种行为模式，用途十分广泛，我们平时可能不知不觉就用到该方法模式

模板方法模式在生活中的应用场景：

- 根据相同的架构创建不同的房子，例如刷漆，材料等都可以DIY，但是基本结构还是相似的
- 考试卷，里面的试题相同，但根据不同人写的答案最终得到不同分数的考卷

该模式即为继承和多态的实现，这里就不写示例代码了...



## 5.10 访问者模式

访问者模式：将算法与其作用的对象隔离开的设计模式即访问者模式。本质就是通过被分离的算法来访问对应的对象。

应用场景：

- 旅游：前往不同的地点（对象），爬山的方式（算法）有所不同
- 推销保险：保险员会根据不同的受众（对象）来采取不同的推销手段（算法）

**示例**

```c++
// Member.h
#pragma once
#include <iostream>
#include <string>

class AbstractAction;
// 成员类的基类
class AbstractMember
{
public:
	AbstractMember(std::string name) : m_name(name) {}
	std::string getName()
	{
		return m_name;
	}
	virtual void accept(AbstractAction* action) = 0;
	virtual ~AbstractMember() {}
protected:
	std::string m_name;
};

class MaleMember : public AbstractMember
{
public:
	using AbstractMember::AbstractMember;
	void accept(AbstractAction* action);
};

class FemaleMember : public AbstractMember
{
public:
	using AbstractMember::AbstractMember;
	void accept(AbstractAction* action);
};
```



```c++
// Member.cpp
#include "Member.h"
#include "Visitor.h"

void MaleMember::accept(AbstractAction* action)
{
	action->maleDoing(this);
}

void FemaleMember::accept(AbstractAction* action)
{
	action->femaleDoing(this);
}
```



```c++
// Visitor.h
#pragma once

class AbstractMember;
// 定义行为对应的基类
class AbstractAction
{
public:
	virtual void maleDoing(AbstractMember* member) = 0;
	virtual void femaleDoing(AbstractMember* member) = 0;
	virtual ~AbstractAction() {}
};

class Anger : public AbstractAction
{
public:
	void maleDoing(AbstractMember* member) override;
	void femaleDoing(AbstractMember* member) override;
	void fight();
	void warning();
};

class Horor : public AbstractAction
{
public:
	void maleDoing(AbstractMember* member) override;
	void femaleDoing(AbstractMember* member)  override;
	void help();
	void thinking();
};
```



```c++
// Visitor.cpp
#include "Visitor.h"
#include "Member.h"
#include <iostream>

void Anger::maleDoing(AbstractMember* member)
{
	std::cout << "我是第九集团军的【" << member->getName() << "】" << std::endl;
	fight();
}

void Anger::femaleDoing(AbstractMember* member)
{
	std::cout << "我是第九集团军的【" << member->getName() << "】" << std::endl;
	warning();
}

void Anger::fight()
{
	std::cout << "--只要我还活着就得和这家伙血战到底！！！" << std::endl;
}

void Anger::warning()
{
	std::cout << "--大坏蛋，休想靠近我和我的伙伴一步~~~" << std::endl;
}

void Horor::maleDoing(AbstractMember* member)
{
	std::cout << "我是第九集团军的【" << member->getName() << "】" << std::endl;
	thinking();
}

void Horor::femaleDoing(AbstractMember* member)
{
	std::cout << "我是第九集团军的【" << member->getName() << "】" << std::endl;
	help();
}

void Horor::help()
{
	std::cout << "--局座救命，这边快顶不住了，请求支援" << std::endl;
}

void Horor::thinking()
{
	std::cout << "--这对手太强了，遭不住了，我得想一个办法" << std::endl;
}
```



```c++
// 测试程序
#include "Visitor.h"
#include "Member.h"
#include <list>
#include <vector>
using namespace std;

// 测试类
class Team
{
public:
	Team()
	{
		m_action.push_back(new Anger);
		m_action.push_back(new Horor);
	}
	void addMember(AbstractMember* member)
	{
		m_member.push_back(member);
	}

	void deleteMember(AbstractMember* member)
	{
		m_member.remove(member);
	}

	void display()
	{
		for (const auto& item : m_member)
		{
			int index = rand() % 2;
			item->accept(m_action[index]);
		}
	}

	~Team()
	{
		for (const auto& item : m_member)
		{
			delete item;
		}

		for (const auto& item : m_action)
		{
			delete item;
		}
	}
private:
	// 对于m_member，由于需要经常性的增删 ，所以选择 list 容器进行修改
	list<AbstractMember*> m_member;
	// 对于 m_action，我们只需要访问即可，所以选用 vector 容器
	vector<AbstractAction*> m_action;
};
int main()
{
	// 生成随机数种子
	srand(time(NULL));
	vector<string> names{ "路飞", "索隆","山治", "乔巴", "弗兰奇", "乌索普", "布鲁克" };
	Team* team = new Team;

	for (const auto& item : names)
	{
		team->addMember(new MaleMember(item));
	}
	team->addMember(new FemaleMember("娜美"));
	team->addMember(new FemaleMember("罗宾"));

	team->display();
	delete team;
	return 0;
}
```



访问者模式适用于数据结构比较稳定的系统，同时访问者模式也是行为模式中最复杂的一种模式，访问者模式中还存在一个==双分派==技术，上述代码中主要体现在 `accept()` 函数中

- 在调用成员函数 `accept()` 时，将具体的行为状态通过参数传递给 member
- 同时 member 这个状态对象，又通过调用自身的行为函数，将当前成员对象传递给状态对象

